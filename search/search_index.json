{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to MkDocs Multi-repo docs","title":"Welcome to MkDocs"},{"location":"#welcome-to-mkdocs","text":"Multi-repo docs","title":"Welcome to MkDocs"},{"location":"onos-config/","text":"onos-config ONOS Configuration subsystem built using the \u00b5ONOS architecture Design Objectives gNMI provides transactionality with respect to a single device; all configuration operations specified as part of a single batch are all applied or none of them are. The core capability of the configuration platform should build on this gNMI feature to: Provide ability to apply a batch of operations (via NB gNMI API) targeted at multiple devices to be performed as a transaction; either all changes are applied to all devices or none of the changes are applied to any of the devices. Track configuration change transactions applied to a set of devices over time and allow rollback (via NB admin API) to previous configuration checkpoints demarcated by the transactions. The above features are the principal objectives for the configuration management platform. Second order objectives are as follows: Support high-availability and distributed operation, including rolling upgrades Support networks comprising of ~50 devices, ~5000 ports and rate of ~10K incremental configuration transactions per day Additional Features (to be integrated with the above) The following set of features will be required to support the real-world use-cases, but may not necessarily be part of the code configuration subsystem and instead can be provided as additional layers: Ability to preload initial configuration about devices that have not yet been discovered - or even deployed Dry run capability - validate configuration with respect to model, but also with respect to existing business constraints or policies Import existing device configuration Configuration Intents - ability to translate high-level (possibly network-wide) configuration specifications into lower-level (device-specific) operations Key Tenets Principal northbound API for the subsystem will be gNMI and gNOI. These interfaces are already accepted standards and are well-defined, low-profile interfaces with support for transaction semantics. YANG models that will be exposed as part of the NB API are yet to be determined (or defined). Enhanced northbound API will be a gRPC service providing access to administrative functionality. Applications can navigate the change-log and roll-back various changes as they were previously submitted via gNMI Southbound API for the subsystem will be gNMI and gNOI. This will allow direct use with Stratum-compliant switches without requiring an adaptation layer. Adapters can be created for devices that do not directly support gNMI/gNOI interfaces. Such adapters can be deployed either as proxy agents or potentially can be hosted on the devices themselves. Diagnostic gRPC service will allow for inspection of internal state using various remote tools. This interface is not subject to backward compatibility constraints. The subsystem will be designed as a separate entity to allow its use with the existing ONOS 2.0 architecture and to fit with the NG ONOS architecture. High-Level Design Additional Documentation How to contribute to onos-config project How to build onos-config server, related commands and Docker image How to run onos-config server and related commands How to deploy onos-config in a Kubernetes cluster How to test onos-config integration tests with onit How to onboard your device extending onos-config with Model Plugins Developer workflow summary for onos-config project Contacts and Meetings for onos-config project","title":"onos-config"},{"location":"onos-config/#onos-config","text":"ONOS Configuration subsystem built using the \u00b5ONOS architecture","title":"onos-config"},{"location":"onos-config/#design-objectives","text":"gNMI provides transactionality with respect to a single device; all configuration operations specified as part of a single batch are all applied or none of them are. The core capability of the configuration platform should build on this gNMI feature to: Provide ability to apply a batch of operations (via NB gNMI API) targeted at multiple devices to be performed as a transaction; either all changes are applied to all devices or none of the changes are applied to any of the devices. Track configuration change transactions applied to a set of devices over time and allow rollback (via NB admin API) to previous configuration checkpoints demarcated by the transactions. The above features are the principal objectives for the configuration management platform. Second order objectives are as follows: Support high-availability and distributed operation, including rolling upgrades Support networks comprising of ~50 devices, ~5000 ports and rate of ~10K incremental configuration transactions per day","title":"Design Objectives"},{"location":"onos-config/#additional-features-to-be-integrated-with-the-above","text":"The following set of features will be required to support the real-world use-cases, but may not necessarily be part of the code configuration subsystem and instead can be provided as additional layers: Ability to preload initial configuration about devices that have not yet been discovered - or even deployed Dry run capability - validate configuration with respect to model, but also with respect to existing business constraints or policies Import existing device configuration Configuration Intents - ability to translate high-level (possibly network-wide) configuration specifications into lower-level (device-specific) operations","title":"Additional Features (to be integrated with the above)"},{"location":"onos-config/#key-tenets","text":"Principal northbound API for the subsystem will be gNMI and gNOI. These interfaces are already accepted standards and are well-defined, low-profile interfaces with support for transaction semantics. YANG models that will be exposed as part of the NB API are yet to be determined (or defined). Enhanced northbound API will be a gRPC service providing access to administrative functionality. Applications can navigate the change-log and roll-back various changes as they were previously submitted via gNMI Southbound API for the subsystem will be gNMI and gNOI. This will allow direct use with Stratum-compliant switches without requiring an adaptation layer. Adapters can be created for devices that do not directly support gNMI/gNOI interfaces. Such adapters can be deployed either as proxy agents or potentially can be hosted on the devices themselves. Diagnostic gRPC service will allow for inspection of internal state using various remote tools. This interface is not subject to backward compatibility constraints. The subsystem will be designed as a separate entity to allow its use with the existing ONOS 2.0 architecture and to fit with the NG ONOS architecture.","title":"Key Tenets"},{"location":"onos-config/#high-level-design","text":"","title":"High-Level Design"},{"location":"onos-config/#additional-documentation","text":"How to contribute to onos-config project How to build onos-config server, related commands and Docker image How to run onos-config server and related commands How to deploy onos-config in a Kubernetes cluster How to test onos-config integration tests with onit How to onboard your device extending onos-config with Model Plugins Developer workflow summary for onos-config project Contacts and Meetings for onos-config project","title":"Additional Documentation"},{"location":"onos-config/build/golang-build/","text":"Developer Docker Container The purpose of this docker container is to provide a minimal environment for building and validating the project. As such this container can be used as part of the Travis CI. Using the Container The container can be used by running it with a mount that points to the local workspace and setting the project top-level directory as the work directory. It will run make using the top-level Makefile in that work directory. Optionally, you may specify the desired make target if you don't wish to run the default one. For example, to build onos-config project, run the following: > docker run -it -v `pwd`:/go/src/github.com/onosproject/onos-config \\ -w /go/src/github.com/onosproject/onos-config \\ onosproject/golang-build:stable Building the Container If you need to customize and rebuild the container, run the following command: > docker build -t onosproject/golang-build:latest build/golang-build Note that to use the locally built Docker image, you will have to use the latest tag instead of the stable one.","title":"Developer Docker Container"},{"location":"onos-config/build/golang-build/#developer-docker-container","text":"The purpose of this docker container is to provide a minimal environment for building and validating the project. As such this container can be used as part of the Travis CI.","title":"Developer Docker Container"},{"location":"onos-config/build/golang-build/#using-the-container","text":"The container can be used by running it with a mount that points to the local workspace and setting the project top-level directory as the work directory. It will run make using the top-level Makefile in that work directory. Optionally, you may specify the desired make target if you don't wish to run the default one. For example, to build onos-config project, run the following: > docker run -it -v `pwd`:/go/src/github.com/onosproject/onos-config \\ -w /go/src/github.com/onosproject/onos-config \\ onosproject/golang-build:stable","title":"Using the Container"},{"location":"onos-config/build/golang-build/#building-the-container","text":"If you need to customize and rebuild the container, run the following command: > docker build -t onosproject/golang-build:latest build/golang-build Note that to use the locally built Docker image, you will have to use the latest tag instead of the stable one.","title":"Building the Container"},{"location":"onos-config/build/protoc-go/","text":"Protoc Go Docker Container The purpose of this docker container is to allow running the protobuf compiler in an isolated environment to free the developers from having to install protoc themselves. Using the Container The container can be used by running it with a mount that points to the local workspace, setting the project top-level directory as the work directory and specifying the project-specific compile-protos.sh script as the entrypoint. For example, to compile the onos-config project proto files, run the following: > docker run -it -v `pwd`:/go/src/github.com/onosproject/onos-config \\ -w /go/src/github.com/onosproject/onos-config \\ --entrypoint pkg/northbound/proto/compile-protos.sh \\ onosproject/protoc-go:stable Building the Container If you need to customize and rebuild the container, run the following command: > docker build -t onosproject/protoc-go:latest build/protoc-go Note that to use the locally built Docker image, you will have to use the latest tag instead of the stable one.","title":"Protoc Go Docker Container"},{"location":"onos-config/build/protoc-go/#protoc-go-docker-container","text":"The purpose of this docker container is to allow running the protobuf compiler in an isolated environment to free the developers from having to install protoc themselves.","title":"Protoc Go Docker Container"},{"location":"onos-config/build/protoc-go/#using-the-container","text":"The container can be used by running it with a mount that points to the local workspace, setting the project top-level directory as the work directory and specifying the project-specific compile-protos.sh script as the entrypoint. For example, to compile the onos-config project proto files, run the following: > docker run -it -v `pwd`:/go/src/github.com/onosproject/onos-config \\ -w /go/src/github.com/onosproject/onos-config \\ --entrypoint pkg/northbound/proto/compile-protos.sh \\ onosproject/protoc-go:stable","title":"Using the Container"},{"location":"onos-config/build/protoc-go/#building-the-container","text":"If you need to customize and rebuild the container, run the following command: > docker build -t onosproject/protoc-go:latest build/protoc-go Note that to use the locally built Docker image, you will have to use the latest tag instead of the stable one.","title":"Building the Container"},{"location":"onos-config/configs/","text":"Synchronize to deployments folder After editing or changing any of these files, please duplicate them across to * deployments/helm/onos-config/files/configs/","title":"Index"},{"location":"onos-config/configs/#synchronize-to-deployments-folder","text":"After editing or changing any of these files, please duplicate them across to * deployments/helm/onos-config/files/configs/","title":"Synchronize to deployments folder"},{"location":"onos-config/deployments/helm/device-simulator/","text":"ONOS Config Device Simulator Provides a [Helm] chart for deploying \u00b5ONOS Config device simulator on [Kubernetes]. See the documentation for more info.","title":"Index"},{"location":"onos-config/deployments/helm/device-simulator/#onos-config-device-simulator","text":"Provides a [Helm] chart for deploying \u00b5ONOS Config device simulator on [Kubernetes]. See the documentation for more info.","title":"ONOS Config Device Simulator"},{"location":"onos-config/deployments/helm/device-simulator/files/configs/","text":"This folder contains test configurations that are loaded into the application via a ConfigMap when deploying via this Helm chart. The root test configurations are copied here because Helm does not allow files outside the chart to be accessed via templates. Changes to the root test configurations should be reflected here.","title":"Index"},{"location":"onos-config/deployments/helm/onos-config/","text":"ONOS Config Helm Chart Provides a [Helm] chart for deploying \u00b5ONOS Config on [Kubernetes]. See the documentation for more info.","title":"Index"},{"location":"onos-config/deployments/helm/onos-config/#onos-config-helm-chart","text":"Provides a [Helm] chart for deploying \u00b5ONOS Config on [Kubernetes]. See the documentation for more info.","title":"ONOS Config Helm Chart"},{"location":"onos-config/deployments/helm/onos-config/files/certs/","text":"This folder contains self-signed certificates for use in testing. DO NOT USE THESE CERTIFICATES IN PRODUCTION! The certificates were generated with the https://github.com/onosproject/simulators/blob/master/pkg/certs/generate_certs.sh script as generate-certs.sh onos-config.opennetworking.org In this folder they must be (re)named * tls.cacrt * tls.crt * tls.key Use openssl x509 -in deployments/helm/onos-config/files/certs/tls.crt -text -noout to verify the contents (especially the subject). There is another Cert for onos-config in test/certs but these were created with: generate-certs.sh onos-config and are left named onf.cacrt, onos-config.key and onos-config.crt","title":"Index"},{"location":"onos-config/deployments/helm/onos-config/files/configs/","text":"This folder contains test configurations that are loaded into the application via a ConfigMap when deploying via this Helm chart. The root test configurations are copied here because Helm does not allow files outside the chart to be accessed via templates. Changes to the root test configurations should be reflected here. Do not copy the deviceStore-sample.json file in here - it will be generated automatically from configmap.yaml","title":"Index"},{"location":"onos-config/docs/build/","text":"Building onos-config In order the build the project, developers are expected to install the required development tools . Currently, the project build and validation is driven by a top-level Makefile , which supports the following usage: > make help build build the Go binaries and run all validations (default) clean remove all the build artifacts coverage generate unit test coverage data deps ensure that the required dependencies are in place gofmt run the Go format validation images build all Docker images kind build Docker images and add them to the currently configured kind cluster license_check examine and ensure license headers exist linters examines Go source code and reports coding problems onos-config-base-docker build onos-config base Docker image protos compile the protobuf files (using protoc-go Docker) test run the unit tests and source code validation Building Go binaries To build the project, simply type make . This will check for required dependencies, compile the Go binaries and then perform all required validation steps, which includes unit tests, Go code formating, Go lint, Go vetting and license header compliance check. In future, there may be other tests. | Note that since the build relies on Go modules, you must export GO111MODULE=on . Building Docker images To allow deployment of onos-config in a Kubernetes cluster, the Makefile allows creation of two separate Docker images. The main Docker image is onosproject/onos-config , which is the main program that acts as a server that provides various gRPC interfaces to application. This include gNMI and the AdminService and DiagnosticService . The second Docker image is onosproject/onos-cli , which provides a command-line shell that can be deployed as an ephemeral container inside the Kubernetes cluster and which provides access to the onos CLI commands for remotely interacting with the services provided by onosproject/onos-config . You can build both images by running make images . Compiling protobufs To compile Google Protocol Buffer files ( *.proto ) and to generate Go source files from them, simply run make protos . Provided you changed the source *.proto files, this will modify the corresponding *.pb.go source files. Although these files are auto-generated, developers are expected to check them in, anytime they change as a result of changing the *.proto files. The protoc compiler is run using onosproject/proto-go Docker image, which has been published to remove the need for developers to install their own protoc compiler and its Go plugin. The Makefile makes this transparent. Bulding Documentation Documentation is published at https://godoc.org/github.com/onosproject/onos-config If you wish to see a version of it locally run: godoc -goroot=$HOME/go and then browse at http://localhost:6060/pkg/github.com/onosproject/onos-config/","title":"Building onos-config"},{"location":"onos-config/docs/build/#building-onos-config","text":"In order the build the project, developers are expected to install the required development tools . Currently, the project build and validation is driven by a top-level Makefile , which supports the following usage: > make help build build the Go binaries and run all validations (default) clean remove all the build artifacts coverage generate unit test coverage data deps ensure that the required dependencies are in place gofmt run the Go format validation images build all Docker images kind build Docker images and add them to the currently configured kind cluster license_check examine and ensure license headers exist linters examines Go source code and reports coding problems onos-config-base-docker build onos-config base Docker image protos compile the protobuf files (using protoc-go Docker) test run the unit tests and source code validation","title":"Building onos-config"},{"location":"onos-config/docs/build/#building-go-binaries","text":"To build the project, simply type make . This will check for required dependencies, compile the Go binaries and then perform all required validation steps, which includes unit tests, Go code formating, Go lint, Go vetting and license header compliance check. In future, there may be other tests. | Note that since the build relies on Go modules, you must export GO111MODULE=on .","title":"Building Go binaries"},{"location":"onos-config/docs/build/#building-docker-images","text":"To allow deployment of onos-config in a Kubernetes cluster, the Makefile allows creation of two separate Docker images. The main Docker image is onosproject/onos-config , which is the main program that acts as a server that provides various gRPC interfaces to application. This include gNMI and the AdminService and DiagnosticService . The second Docker image is onosproject/onos-cli , which provides a command-line shell that can be deployed as an ephemeral container inside the Kubernetes cluster and which provides access to the onos CLI commands for remotely interacting with the services provided by onosproject/onos-config . You can build both images by running make images .","title":"Building Docker images"},{"location":"onos-config/docs/build/#compiling-protobufs","text":"To compile Google Protocol Buffer files ( *.proto ) and to generate Go source files from them, simply run make protos . Provided you changed the source *.proto files, this will modify the corresponding *.pb.go source files. Although these files are auto-generated, developers are expected to check them in, anytime they change as a result of changing the *.proto files. The protoc compiler is run using onosproject/proto-go Docker image, which has been published to remove the need for developers to install their own protoc compiler and its Go plugin. The Makefile makes this transparent.","title":"Compiling protobufs"},{"location":"onos-config/docs/build/#bulding-documentation","text":"Documentation is published at https://godoc.org/github.com/onosproject/onos-config If you wish to see a version of it locally run: godoc -goroot=$HOME/go and then browse at http://localhost:6060/pkg/github.com/onosproject/onos-config/","title":"Bulding Documentation"},{"location":"onos-config/docs/cli/","text":"Administrative and Diagnostic Command-Line The project provides a command-line facilities for remotely interacting with the administrative and diagnostic services of the onos-config server. The commands are available at run-time using the consolidated onos client hosted in the onos-cli repository, but their implementation is hosted and built here. The documentation about building and deploying the consolidate onos client or its Docker container is available in the onos-cli GitHub repository. Usage > onos config --help ONOS configuration subsystem commands Usage: onos config [command] Available Commands: add Add a config resource config Read and update the config configuration get Get config resources rollback Rolls-back a network configuration change Flags: -h, --help help for config Use \"onos config [command] --help\" for more information about a command. Global Flags Since the onos command is a client, it requires the address of the server as well as the paths to the key and the certificate to establish secure connection to the server. These options are global to all commands and can be persisted to avoid having to specify them for each command. For example, you can set the default server address as follows: > onos config config set address onos-config-server:5150 Subsequent usages of the onos command can then abstain from using the --address option to indicate the server address, resulting in easier usage. Example Commands List Network Changes For example, to list all network changes submitted through the northbound gNMI interface run: > onos config get net-changes ... Rollback Network Change To rollback a network use the rollback admin tool. This will rollback the last network change unless a specific change is given with the changename parameter > onos config rollback Change-VgUAZI928B644v/2XQ0n24x0SjA= Listing and Loading model plugins A model plugin is a shared object library that represents the YANG models of a particular Device Type and Version. The plugin allows user to create and load their own device models in to onos-config that can be used for validating that configuration changes observe the structure of the YANG models in use on the device. This improves usability by pushing information about the devices' model back up to the onos-config gNMI northbound interface. Model plugins can be loaded at the startup of onos-config by (repeated) --modelPlugin options, or they can be loaded at run time. To see the list of currently loaded plugins use the command: > onos config get plugins To load a plugin dynamically at runtime use the command: > onos config add plugin <full path and filename of a compatible shared object library on target machine> NOTE: Model Plugins cannot be dynamically unloaded - a restart of onos-config is required to unload. In a distributed environment the ModelPlugin will have to be loaded on all instances of onos-config Other Diagnostic Commands There are a number of commands that provide internal view into the state the onos-config store. These tools use a special-purpose gRPC interfaces to obtain the internal meta-data from the running onos-config process. Please note that these tools are intended purely for diagnostics and should not be relied upon for programmatic purposes as they are not subject to any backward compatibility guarantees. Changes For example, run the following to list all changes submitted through the northbound gNMI as they are tracked by the system broken-up into device specific batches: > onos config get changes ... For a specific change specify the optional changeId argument. Configs To get details from the Configuration store use > onos config get configs ... For the configuration for a specific device use the optional deviceId argument. Devicetree To get the aggregate configuration of a device in a hierarchical JSON structure from the store use: > onos config get devicetree --layer 0 Device1 DEVICE CONFIGURATION TYPE VERSION Device1 Device1-1.0.0 TestDevice 1.0.0 CHANGE: 2uUbeEV4i3ADedjeORmgQt6CVDM= CHANGE: tAk3GZSh1qbdhdm5414r46RLvqw= CHANGE: MY8s8Opw+xjbcARIMzIpUIzeXv0= TREE: {\"cont1a\":{\"cont2a\":{\"leaf2a\":13,\"leaf2b\":1.14159,\"leaf2c\":\"def\",\"leaf2d\":0.002,\"leaf2e\":[-99,-4,5,200],\"leaf2g\":false},\"leaf1a\":\"abcdef\",\"list2a\":[{\"name\":\"txout1\",\"tx-power\":8},{\"name\":\"txout3\",\"tx-power\":16}]},\"test1:leafAtTopLevel\":\"WXY-1234\"} This displays the list of changes IDs and the aggregate effect of layering each one on top of the other. This is effective configuration. By default all layers are shown ( layer=0 ). To show the previous effective configuration use layer=-1 To display the devices trees for all devices, just omit the device name.","title":"Administrative and Diagnostic Command-Line"},{"location":"onos-config/docs/cli/#administrative-and-diagnostic-command-line","text":"The project provides a command-line facilities for remotely interacting with the administrative and diagnostic services of the onos-config server. The commands are available at run-time using the consolidated onos client hosted in the onos-cli repository, but their implementation is hosted and built here. The documentation about building and deploying the consolidate onos client or its Docker container is available in the onos-cli GitHub repository.","title":"Administrative and Diagnostic Command-Line"},{"location":"onos-config/docs/cli/#usage","text":"> onos config --help ONOS configuration subsystem commands Usage: onos config [command] Available Commands: add Add a config resource config Read and update the config configuration get Get config resources rollback Rolls-back a network configuration change Flags: -h, --help help for config Use \"onos config [command] --help\" for more information about a command.","title":"Usage"},{"location":"onos-config/docs/cli/#global-flags","text":"Since the onos command is a client, it requires the address of the server as well as the paths to the key and the certificate to establish secure connection to the server. These options are global to all commands and can be persisted to avoid having to specify them for each command. For example, you can set the default server address as follows: > onos config config set address onos-config-server:5150 Subsequent usages of the onos command can then abstain from using the --address option to indicate the server address, resulting in easier usage.","title":"Global Flags"},{"location":"onos-config/docs/cli/#example-commands","text":"","title":"Example Commands"},{"location":"onos-config/docs/cli/#list-network-changes","text":"For example, to list all network changes submitted through the northbound gNMI interface run: > onos config get net-changes ...","title":"List Network Changes"},{"location":"onos-config/docs/cli/#rollback-network-change","text":"To rollback a network use the rollback admin tool. This will rollback the last network change unless a specific change is given with the changename parameter > onos config rollback Change-VgUAZI928B644v/2XQ0n24x0SjA=","title":"Rollback Network Change"},{"location":"onos-config/docs/cli/#listing-and-loading-model-plugins","text":"A model plugin is a shared object library that represents the YANG models of a particular Device Type and Version. The plugin allows user to create and load their own device models in to onos-config that can be used for validating that configuration changes observe the structure of the YANG models in use on the device. This improves usability by pushing information about the devices' model back up to the onos-config gNMI northbound interface. Model plugins can be loaded at the startup of onos-config by (repeated) --modelPlugin options, or they can be loaded at run time. To see the list of currently loaded plugins use the command: > onos config get plugins To load a plugin dynamically at runtime use the command: > onos config add plugin <full path and filename of a compatible shared object library on target machine> NOTE: Model Plugins cannot be dynamically unloaded - a restart of onos-config is required to unload. In a distributed environment the ModelPlugin will have to be loaded on all instances of onos-config","title":"Listing and Loading model plugins"},{"location":"onos-config/docs/cli/#other-diagnostic-commands","text":"There are a number of commands that provide internal view into the state the onos-config store. These tools use a special-purpose gRPC interfaces to obtain the internal meta-data from the running onos-config process. Please note that these tools are intended purely for diagnostics and should not be relied upon for programmatic purposes as they are not subject to any backward compatibility guarantees.","title":"Other Diagnostic Commands"},{"location":"onos-config/docs/cli/#changes","text":"For example, run the following to list all changes submitted through the northbound gNMI as they are tracked by the system broken-up into device specific batches: > onos config get changes ... For a specific change specify the optional changeId argument.","title":"Changes"},{"location":"onos-config/docs/cli/#configs","text":"To get details from the Configuration store use > onos config get configs ... For the configuration for a specific device use the optional deviceId argument.","title":"Configs"},{"location":"onos-config/docs/cli/#devicetree","text":"To get the aggregate configuration of a device in a hierarchical JSON structure from the store use: > onos config get devicetree --layer 0 Device1 DEVICE CONFIGURATION TYPE VERSION Device1 Device1-1.0.0 TestDevice 1.0.0 CHANGE: 2uUbeEV4i3ADedjeORmgQt6CVDM= CHANGE: tAk3GZSh1qbdhdm5414r46RLvqw= CHANGE: MY8s8Opw+xjbcARIMzIpUIzeXv0= TREE: {\"cont1a\":{\"cont2a\":{\"leaf2a\":13,\"leaf2b\":1.14159,\"leaf2c\":\"def\",\"leaf2d\":0.002,\"leaf2e\":[-99,-4,5,200],\"leaf2g\":false},\"leaf1a\":\"abcdef\",\"list2a\":[{\"name\":\"txout1\",\"tx-power\":8},{\"name\":\"txout3\",\"tx-power\":16}]},\"test1:leafAtTopLevel\":\"WXY-1234\"} This displays the list of changes IDs and the aggregate effect of layering each one on top of the other. This is effective configuration. By default all layers are shown ( layer=0 ). To show the previous effective configuration use layer=-1 To display the devices trees for all devices, just omit the device name.","title":"Devicetree"},{"location":"onos-config/docs/community-info/","text":"Contacts and Calendars Mailing list The onos-config project currently leverages the ONOS developers mailing list: onos-dev@onosprojects.org Note We kindly ask to have the start of the subject to be [onos-config] Slack channel The onos-config project has a slack channel in the onosproject slack: #micro-onos . If you want to join the onosproject slack please join here and the subscribe to our channel. Calendar The onos-config project leverages the common ONOS calendar which can be found at this link . If you instead would like to add the calendar to your personal Google Calendar, please add the copy the following string onosproject.org_6l261cnjim09dv9sulta3bgcmc@group.calendar.google.com to your external calendar (left bar in the Google Calendar online application). Daily Stand-up The onos-config project team holds a short stand-up every day at 10 AM PST, 6 PM GMT, 7 PM CET. Feel free to join to learn what the team is up to and discuss your latest work with us. meeting link Technical Steering Team The technical steering team has PUBLIC and RECORDED meetings at 9 AM PST, 5 PM GMT, 6 PM CET on Wednesday every 2 weeks to discuss different topics. You can find a detailed agenda and next meeting information on the TST Wiki .","title":"Contacts and Calendars"},{"location":"onos-config/docs/community-info/#contacts-and-calendars","text":"","title":"Contacts and Calendars"},{"location":"onos-config/docs/community-info/#mailing-list","text":"The onos-config project currently leverages the ONOS developers mailing list: onos-dev@onosprojects.org Note We kindly ask to have the start of the subject to be [onos-config]","title":"Mailing list"},{"location":"onos-config/docs/community-info/#slack-channel","text":"The onos-config project has a slack channel in the onosproject slack: #micro-onos . If you want to join the onosproject slack please join here and the subscribe to our channel.","title":"Slack channel"},{"location":"onos-config/docs/community-info/#calendar","text":"The onos-config project leverages the common ONOS calendar which can be found at this link . If you instead would like to add the calendar to your personal Google Calendar, please add the copy the following string onosproject.org_6l261cnjim09dv9sulta3bgcmc@group.calendar.google.com to your external calendar (left bar in the Google Calendar online application).","title":"Calendar"},{"location":"onos-config/docs/community-info/#daily-stand-up","text":"The onos-config project team holds a short stand-up every day at 10 AM PST, 6 PM GMT, 7 PM CET. Feel free to join to learn what the team is up to and discuss your latest work with us. meeting link","title":"Daily Stand-up"},{"location":"onos-config/docs/community-info/#technical-steering-team","text":"The technical steering team has PUBLIC and RECORDED meetings at 9 AM PST, 5 PM GMT, 6 PM CET on Wednesday every 2 weeks to discuss different topics. You can find a detailed agenda and next meeting information on the TST Wiki .","title":"Technical Steering Team"},{"location":"onos-config/docs/contributing/","text":"Contributing to onos-config The ONOS team hopes for and welcomes contributions from the community at large. To become a contributor, you will first need to sign a CLA. After that, simply follow the process outlined below for submitting your patches on GitHub. Workflow Contributions are accepted via GitHub Pull Requests submitted from the developer's own Fork of the onos-config repository. The following diagram illustrates the steps required to establish such a Fork and to create a Pull Request. 1. Fork on GitHub Visit https://github.com/onosproject/onos-config Click Fork button (top right) to establish your own GitHub repository fork. 2. Clone Fork The onos-config code should be placed under your GOPATH (per Go workspace conventions ) using the following procedure: If you have not set and exported the GOPATH environment variable, please do so: export GOPATH=$(go env GOPATH) Similarly, set and export the GIT_USER environment variable to match your github profile name: export GIT_USER={your github profile name} Then, clone your fork of the onos-config repository: ONOS_ROOT=$GOPATH/src/github.com/onosproject mkdir -p $ONOS_ROOT && cd $ONOS_ROOT git clone https://github.com/$GIT_USER/onos-config.git # or: git clone git@github.com:$GIT_USER/onos-config.git cd $ONOS_ROOT/onos-config git remote add upstream https://github.com/onosproject/onos-config.git # or: git remote add upstream git@github.com:onosproject/onos-config.git # Never push to upstream master git remote set-url --push upstream no_push # Confirm that your remotes make sense: git remote -v 3. Branch Get your local master up to date: cd $GOPATH/src/github.com/onosproject/onos-config git fetch upstream git checkout master git rebase upstream/master Branch from it: git checkout -b myfeature Then edit code on the myfeature branch. 4. Keep Branch in Sync While on your myfeature branch git fetch upstream git rebase upstream/master Please don't use git pull instead of the above fetch / rebase . git pull does a merge, which leaves merge commits. These make the commit history messy and violate the principle that commits ought to be individually understandable and useful (see below). You can also consider changing your .git/config file via git config branch.autoSetupRebase always to change the behavior of git pull . 5. Commit Commit your changes. git commit If you make other changes pleas add them to a new commit and thus keep the history of your work. Your branch, after you open a pull request, will be merged with a squash and commit strategy, thus showing as only one commit. 6. Push When ready to review (or just to establish an offsite backup or your work), push your branch to your fork on github.com : git push origin myfeature 7. Create a Pull Request Visit your fork at https://github.com/$user/onos-config Click the Compare & Pull Request button next to your myfeature branch. Please follow the pull request guidelines . If you have upstream write access , please refrain from using the GitHub UI for creating PRs, because GitHub will create the PR branch inside the main repository rather than inside your fork. Get a Code Review Once your pull request has been opened it will be assigned to one or more reviewers. Those reviewers will do a thorough code review, looking for correctness, bugs, opportunities for improvement, documentation and comments, and style. Commit changes made in response to review comments to the same branch on your fork. Very small PRs are easy to review. Very large PRs are very difficult to review. Squash and Merge Upon merge (by either you or your reviewer), all commits left on the review branch should represent meaningful milestones or units of work. Use commits to add clarity to the development and review process. Before merging a PR, squash any fix review feedback , typo , merged , and rebased sorts of commits. It is not imperative that every commit in a PR compile and pass tests independently, but it is worth striving for. In particular, if you happened to have used git merge and have merge commits, please squash those away: they do not meet the above test. A nifty way to manage the commits in your PR is to do an interactive rebase , which will let you tell git what to do with every commit: git fetch upstream git rebase -i upstream/master For mass automated fixups (e.g. automated doc formatting), use one or more commits for the changes to tooling and a final commit to apply the fixup en masse. This makes reviews easier. How to Revert a Commit In case you wish to revert a commit, use the following instructions. If you have upstream write access , please refrain from using the Revert button in the GitHub UI for creating the PR, because GitHub will create the PR branch inside the main repository rather than inside your fork. 1. Create a branch and sync it with upstream. # create a branch git checkout -b myrevert # sync the branch with upstream git fetch upstream git rebase upstream/master 2. Revert the prior commit(s) If the commit you wish to revert it a merge commit, run this: # SHA is the hash of the merge commit you wish to revert git revert -m 1 SHA If it is a single commit, then run the following: # SHA is the hash of the single commit you wish to revert git revert SHA The above will create a new commit reverting the changes. 3. Push this new commit to your remote. git push ${your_remote_name} myrevert 4. Create a pull request using this branch. Community Guidelines This project follows Google's Open Source Community Guidelines .","title":"Contributing to onos-config"},{"location":"onos-config/docs/contributing/#contributing-to-onos-config","text":"The ONOS team hopes for and welcomes contributions from the community at large. To become a contributor, you will first need to sign a CLA. After that, simply follow the process outlined below for submitting your patches on GitHub.","title":"Contributing to onos-config"},{"location":"onos-config/docs/contributing/#workflow","text":"Contributions are accepted via GitHub Pull Requests submitted from the developer's own Fork of the onos-config repository. The following diagram illustrates the steps required to establish such a Fork and to create a Pull Request.","title":"Workflow"},{"location":"onos-config/docs/contributing/#1-fork-on-github","text":"Visit https://github.com/onosproject/onos-config Click Fork button (top right) to establish your own GitHub repository fork.","title":"1. Fork on GitHub"},{"location":"onos-config/docs/contributing/#2-clone-fork","text":"The onos-config code should be placed under your GOPATH (per Go workspace conventions ) using the following procedure: If you have not set and exported the GOPATH environment variable, please do so: export GOPATH=$(go env GOPATH) Similarly, set and export the GIT_USER environment variable to match your github profile name: export GIT_USER={your github profile name} Then, clone your fork of the onos-config repository: ONOS_ROOT=$GOPATH/src/github.com/onosproject mkdir -p $ONOS_ROOT && cd $ONOS_ROOT git clone https://github.com/$GIT_USER/onos-config.git # or: git clone git@github.com:$GIT_USER/onos-config.git cd $ONOS_ROOT/onos-config git remote add upstream https://github.com/onosproject/onos-config.git # or: git remote add upstream git@github.com:onosproject/onos-config.git # Never push to upstream master git remote set-url --push upstream no_push # Confirm that your remotes make sense: git remote -v","title":"2. Clone Fork"},{"location":"onos-config/docs/contributing/#3-branch","text":"Get your local master up to date: cd $GOPATH/src/github.com/onosproject/onos-config git fetch upstream git checkout master git rebase upstream/master Branch from it: git checkout -b myfeature Then edit code on the myfeature branch.","title":"3. Branch"},{"location":"onos-config/docs/contributing/#4-keep-branch-in-sync","text":"While on your myfeature branch git fetch upstream git rebase upstream/master Please don't use git pull instead of the above fetch / rebase . git pull does a merge, which leaves merge commits. These make the commit history messy and violate the principle that commits ought to be individually understandable and useful (see below). You can also consider changing your .git/config file via git config branch.autoSetupRebase always to change the behavior of git pull .","title":"4. Keep Branch in Sync"},{"location":"onos-config/docs/contributing/#5-commit","text":"Commit your changes. git commit If you make other changes pleas add them to a new commit and thus keep the history of your work. Your branch, after you open a pull request, will be merged with a squash and commit strategy, thus showing as only one commit.","title":"5. Commit"},{"location":"onos-config/docs/contributing/#6-push","text":"When ready to review (or just to establish an offsite backup or your work), push your branch to your fork on github.com : git push origin myfeature","title":"6. Push"},{"location":"onos-config/docs/contributing/#7-create-a-pull-request","text":"Visit your fork at https://github.com/$user/onos-config Click the Compare & Pull Request button next to your myfeature branch. Please follow the pull request guidelines . If you have upstream write access , please refrain from using the GitHub UI for creating PRs, because GitHub will create the PR branch inside the main repository rather than inside your fork.","title":"7. Create a Pull Request"},{"location":"onos-config/docs/contributing/#get-a-code-review","text":"Once your pull request has been opened it will be assigned to one or more reviewers. Those reviewers will do a thorough code review, looking for correctness, bugs, opportunities for improvement, documentation and comments, and style. Commit changes made in response to review comments to the same branch on your fork. Very small PRs are easy to review. Very large PRs are very difficult to review.","title":"Get a Code Review"},{"location":"onos-config/docs/contributing/#squash-and-merge","text":"Upon merge (by either you or your reviewer), all commits left on the review branch should represent meaningful milestones or units of work. Use commits to add clarity to the development and review process. Before merging a PR, squash any fix review feedback , typo , merged , and rebased sorts of commits. It is not imperative that every commit in a PR compile and pass tests independently, but it is worth striving for. In particular, if you happened to have used git merge and have merge commits, please squash those away: they do not meet the above test. A nifty way to manage the commits in your PR is to do an interactive rebase , which will let you tell git what to do with every commit: git fetch upstream git rebase -i upstream/master For mass automated fixups (e.g. automated doc formatting), use one or more commits for the changes to tooling and a final commit to apply the fixup en masse. This makes reviews easier.","title":"Squash and Merge"},{"location":"onos-config/docs/contributing/#how-to-revert-a-commit","text":"In case you wish to revert a commit, use the following instructions. If you have upstream write access , please refrain from using the Revert button in the GitHub UI for creating the PR, because GitHub will create the PR branch inside the main repository rather than inside your fork.","title":"How to Revert a Commit"},{"location":"onos-config/docs/contributing/#1-create-a-branch-and-sync-it-with-upstream","text":"# create a branch git checkout -b myrevert # sync the branch with upstream git fetch upstream git rebase upstream/master","title":"1. Create a branch and sync it with upstream."},{"location":"onos-config/docs/contributing/#2-revert-the-prior-commits","text":"If the commit you wish to revert it a merge commit, run this: # SHA is the hash of the merge commit you wish to revert git revert -m 1 SHA If it is a single commit, then run the following: # SHA is the hash of the single commit you wish to revert git revert SHA The above will create a new commit reverting the changes.","title":"2. Revert the prior commit(s)"},{"location":"onos-config/docs/contributing/#3-push-this-new-commit-to-your-remote","text":"git push ${your_remote_name} myrevert","title":"3. Push this new commit to your remote."},{"location":"onos-config/docs/contributing/#4-create-a-pull-request-using-this-branch","text":"","title":"4. Create a pull request using this branch."},{"location":"onos-config/docs/contributing/#community-guidelines","text":"This project follows Google's Open Source Community Guidelines .","title":"Community Guidelines"},{"location":"onos-config/docs/debugging/","text":"Debug onos-config in Onit Using Delve Debugging Example #1: Use Goland IDE (Recommended): In this example, we assume you already started an onit cluster. If you haven't done that yet, refer to testing for more details. First, you need to configure your Goland IDE to connect to the remote Delve debugger which is running in the onos-config pod. You can do that by going to Run | Edit Configurations\u2026 | + | Go Remote and configuring the host (in this example localhost ) and port (in this example port 40000 ) your remote debugger is listening on. To start debugging and open a debugger port to the given resource, you can run onit debug command. For example, to forwards a port to the debug port on the onos-config pod, run the following command: ```bash onit debug Forwarding from 127.0.0.1:40000 -> 40000 Forwarding from [::1]:40000 -> 40000 ``` To connect to the debugger using Goland IDE, select the configuration that you created in the first step and click on Debug button as follows: If your Goland IDE connects to the debug server which is running in onos-config pod successfully, then you should be able to see the following message in the logs: ```bash onit get logs .... 2019-07-22T15:09:27Z debug layer=debugger halting 2019-07-22T15:09:28Z debug layer=debugger continuing ``` Suppose we want to add a simulator and debug synchronizer code by setting a few breakpoints in different lines of its file as follows: As you can see above, after setting the breakpoints, you should be able to see some messages in the onos-config pod logs that confirm you set the breakpoints. When we add a simulator the Goland IDE hits the first breakpoint that was set. At this point you can go through the list of variables and goroutines using the debugger dashboard. Suppose we want to have tracepoints instead of breakpoints. Tracepoints don't cause the program execution to break and they can be useful when you need to inspect something, but not stop the program. To do that in Goland IDE, first set a breakpoint and then right-click on the breakpoint and unchecking \"Suspend\" as follows: You can also print a breakpoint hit message , print stack trace , and Evaluate and Log variables using tracepoints without pausing the program. For example, suppose we want to print the address of the device simulator in the synchronizer as we add a device simulator to the onit cluster: Debugging. Example #2: Use Simple Delve Client: In this example, we assume you already started an onit cluster. If you haven't done that yet, refer to testing for more details. First, you need to install Delve on your machine to interact with the debugger in the onos-config pod. To make sure the debugger is installed successfully on your machine, run dlv command which should show its help. To start debugging and open a debugger port to the given resource, you can run onit debug command. For example, to forwards a port to the debug port on the onos-config pod, run the following command: ```bash onit debug Forwarding from 127.0.0.1:40000 -> 40000 Forwarding from [::1]:40000 -> 40000 ``` To connect to the debugger server which is running in the onos-config pod, run the following command from another terminal: ```bash dlv connect localhost:40000 Type 'help' for list of commands. (dlv) ``` If the dlv client connects to the server without any problems, you should be able to see the following message in the logs: bash > onit get logs onos-config-5d56898bdd-zrmt2 .... 2019-07-18T20:55:06Z debug layer=debugger halting To get list of sources that can be used for debugging, run the following command from the dlv CLI: bash (dlv) sources /go/src/github.com/onosproject/onos-config/cmd/onos-config/onos-config.go /go/src/github.com/onosproject/onos-config/modelplugin/Devicesim-1.0.0/devicesim_1_0_0/generated.go /go/src/github.com/onosproject/onos-config/modelplugin/Devicesim-1.0.0/modelmain.go /go/src/github.com/onosproject/onos-config/modelplugin/TestDevice-1.0.0/modelmain.go /go/src/github.com/onosproject/onos-config/modelplugin/TestDevice-1.0.0/testdevice_1_0_0/generated.go /go/src/github.com/onosproject/onos-config/modelplugin/TestDevice-2.0.0/modelmain.go /go/src/github.com/onosproject/onos-config/modelplugin/TestDevice-2.0.0/testdevice_2_0_0/generated.go /go/src/github.com/onosproject/onos-config/pkg/dispatcher/dispatcher.go /go/src/github.com/onosproject/onos-config/pkg/events/configevent.go /go/src/github.com/onosproject/onos-config/pkg/events/events.go /go/src/github.com/onosproject/onos-config/pkg/events/operationalevent.go /go/src/github.com/onosproject/onos-config/pkg/events/responseevent.go /go/src/github.com/onosproject/onos-config/pkg/events/topoevent.go /go/src/github.com/onosproject/onos-config/pkg/manager/getconfig.go /go/src/github.com/onosproject/onos-config/pkg/manager/manager.go /go/src/github.com/onosproject/onos-config/pkg/manager/rollbackconfig.go /go/src/github.com/onosproject/onos-config/pkg/manager/setconfig.go /go/src/github.com/onosproject/onos-config/pkg/modelregistry/modelregistry.go /go/src/github.com/onosproject/onos-config/pkg/northbound/admin/admin.go .... Suppose you want to set a breakpoint at line 83 of synchronizer . To do that, run the following command from dlv CLI: bash (dlv) break onosproject/onos-config/pkg/southbound/synchronizer/synchronizer.go:83 if you set it properly, you should be able to see a message like the following in the logs: bash onit get logs onos-config-5d56898bdd-zrmt2 ... 2019-07-18T21:03:24Z info layer=debugger created breakpoint: &api.Breakpoint{ID:2, Name:\"\", Addr:0xcd62a2, File:\"/go/src/github.com/onosproject/onos-config/pkg/southbound/synchronizer/synchronizer.go\", Line:83, FunctionName:\"github.com/onosproject/onos-config/pkg/southbound/synchronizer.New\", Cond:\"\", Tracepoint:false, TraceReturn:false, Goroutine:false, Stacktrace:0, Variables:[]string(nil), LoadArgs:(*api.LoadConfig)(nil), LoadLocals:(*api.LoadConfig)(nil), HitCount:map[string]uint64{}, TotalHitCount:0x0} Run continue from dlv CLI that runs until breakpoint as follows: bash (dlv) continue Then, add a device simulator using onit add simulator command. When onit cluster is trying to add a device simulator to the cluster, the debugger stops at the breakpoint and you should be able to see an output like the following from the dlv CLI: bash (dlv) continue > github.com/onosproject/onos-config/pkg/southbound/synchronizer.New() /go/src/github.com/onosproject/onos-config/pkg/southbound/synchronizer/synchronizer.go:83 (hits goroutine(9):1 total:1) (PC: 0xcd62a2) In addition, you can check the onos-config logs to make sure the program stops where you expect to stop: bash > onit get logs onos-config-5d56898bdd-zrmt2 2019-07-18T21:16:32Z debug layer=debugger continuing I0718 21:18:09.661372 32 dispatcher.go:103] Registering Device sim1 on channel 0xc000083920 and 0xc000083980 I0718 21:18:09.662158 32 synchronizer.go:64] Connecting to sim1:10161 over gNMI I0718 21:18:09.662369 32 clientManager.go:53] Loading default CA onfca I0718 21:18:09.662607 32 clientManager.go:60] Loading default certificates I0718 21:18:09.702593 32 synchronizer.go:72] sim1:10161 connected over gNMI Suppose we set another breakpoint at line 89 of synchronizer and run continue command from dlv CLI again. The output of dlv CLI and onos-config logs will be like the followings: ```bash (dlv) continue github.com/onosproject/onos-config/pkg/southbound/synchronizer.New() /go/src/github.com/onosproject/onos-config/pkg/southbound/synchronizer/synchronizer.go:89 (hits goroutine(9):1 total:1) (PC: 0xcd64f9) ``` ```bash onit get logs onos-config-5d56898bdd-zrmt2 ... 2019-07-18T21:25:21Z info layer=debugger created breakpoint: &api.Breakpoint{ID:3, Name:\"\", Addr:0xcd64f9, File:\"/go/src/github.com/onosproject/onos-config/pkg/southbound/synchronizer/synchronizer.go\", Line:89, FunctionName:\"github.com/onosproject/onos-config/pkg/southbound/synchronizer.New\", Cond:\"\", Tracepoint:false, TraceReturn:false, Goroutine:false, Stacktrace:0, Variables:[]string(nil), LoadArgs:( api.LoadConfig)(nil), LoadLocals:( api.LoadConfig)(nil), HitCount:map[string]uint64{}, TotalHitCount:0x0} 2019-07-18T21:26:51Z debug layer=debugger continuing I0718 21:26:51.518797 32 synchronizer.go:83] sim1:10161 capabilities supported_models: supported_models: supported_models: supported_models: supported_encodings:JSON supported_encodings:JSON_IETF gNMI_version:\"0.7.0\" I0718 21:26:51.519659 32 synchronizer.go:305] Getting saved config for sim1 ``` if you run continue again, it passes the breakpoint at line 89 and onos-config will keep running: bash > onit get logs onos-config-5d56898bdd-zrmt2 ... 2019-07-18T21:45:01Z debug layer=debugger continuing I0718 21:45:01.034584 32 synchronizer.go:89] sim1:10161 has no initial configuration I0718 21:45:01.053357 32 synchronizer.go:243] subscribe:<prefix:<> subscription:<path:<> sample_interval:15 heartbeat_interval:15 > subscription:<path:<> sample_interval:15 heartbeat_interval:15 > > At this point, you have two breakpoints in the synchronizer . To see list of your breakpoints, you can run breakpoints command from dlv CLI. bash (dlv) breakpoints Breakpoint runtime-fatal-throw at 0x6ab830 for runtime.fatalthrow() /usr/local/go/src/runtime/panic.go:663 (0) Breakpoint unrecovered-panic at 0x6ab8a0 for runtime.fatalpanic() /usr/local/go/src/runtime/panic.go:690 (0) print runtime.curg._panic.arg Breakpoint 4 at 0xcd62a2 for github.com/onosproject/onos-config/pkg/southbound/synchronizer.New() /go/src/github.com/onosproject/onos-config/pkg/southbound/synchronizer/synchronizer.go:83 (1) Breakpoint 5 at 0xcd64f9 for github.com/onosproject/onos-config/pkg/southbound/synchronizer.New() /go/src/github.com/onosproject/onos-config/pkg/southbound/synchronizer/synchronizer.go:89 (0) You can repeat the above steps by adding another simulator to onos-config and monitor dlv CLI and onos-config pod logs. Print Local Variables When you set breakpoints in a file, you can also print local variables as you go through the breakpoints. For example, look at the following piece of code from synchronizer : bash target := southbound.Target{} key, err := target.ConnectTarget(context, *sync.Device) sync.key = key Suppose we add a simulator and we would like to print the value of key when it passes this block of code. You can use print function from dlv CLI to print local variables in the code: bash (dlv) print key github.com/onosproject/onos-config/pkg/southbound.DeviceID { DeviceID: \"sim2:10161\",} or to print capResponse variable: bash (dlv) print capResponse *github.com/openconfig/gnmi/proto/gnmi.CapabilityResponse { SupportedModels: []*github.com/openconfig/gnmi/proto/gnmi.ModelData len: 4, cap: 4, [ *(*\"github.com/openconfig/gnmi/proto/gnmi.ModelData\")(0xc00042e280), *(*\"github.com/openconfig/gnmi/proto/gnmi.ModelData\")(0xc00042e2d0), *(*\"github.com/openconfig/gnmi/proto/gnmi.ModelData\")(0xc00042e320), *(*\"github.com/openconfig/gnmi/proto/gnmi.ModelData\")(0xc00042e370), ], SupportedEncodings: []github.com/openconfig/gnmi/proto/gnmi.Encoding len: 2, cap: 2, [Encoding_JSON (0),Encoding_JSON_IETF (4)], GNMIVersion: \"0.7.0\", Extension: []*github.com/openconfig/gnmi/proto/gnmi_ext.Extension len: 0, cap: 0, nil, XXX_NoUnkeyedLiteral: struct {} {}, XXX_unrecognized: []uint8 len: 0, cap: 0, nil, XXX_sizecache: 0,} You can also check the list of local variables using locals command from dlv CLI, for example: bash (dlv) locals sync = (\"*github.com/onosproject/onos-config/pkg/southbound/synchronizer.Synchronizer\")(0xc000368000) capResponse = (\"*github.com/openconfig/gnmi/proto/gnmi.CapabilityResponse\")(0xc000346d80) target = github.com/onosproject/onos-config/pkg/southbound.Target {Destination: (*\"github.com/openconfig/gnmi/client.Destination\")(0xc0004e00e0), Clt: github.com/onosproject/onos-config/pkg/southbound.GnmiClient(github.com/onosproject/onos-config/pkg/southbound.gnmiClientImpl) *(*\"github.com/onosproject/onos-config/pkg/southbound.GnmiClient\")(0xc0004e0130), Ctx: context.Context(*context.emptyCtx) ...} key = github.com/onosproject/onos-config/pkg/southbound.DeviceID {DeviceID: \"sim1:10161\"} err = error nil capErr = error nil Goroutines To check which goroutine is running when you are going through a piece of code using breakpoints, you can run the following command from dlv CLI: bash (dlv) goroutine Goroutine 12: Runtime: /go/src/github.com/onosproject/onos-config/pkg/southbound/synchronizer/synchronizer.go:83 github.com/onosproject/onos-config/pkg/southbound/synchronizer.New (0xcd62a2) User: /go/src/github.com/onosproject/onos-config/pkg/southbound/synchronizer/synchronizer.go:83 github.com/onosproject/onos-config/pkg/southbound/synchronizer.New (0xcd62a2) Go: /go/src/github.com/onosproject/onos-config/pkg/manager/manager.go:217 github.com/onosproject/onos-config/pkg/manager.(*Manager).Run (0xcdfb0c) Start: /go/src/github.com/onosproject/onos-config/pkg/southbound/synchronizer/factory.go:30 github.com/onosproject/onos-config/pkg/southbound/synchronizer.Factory (0xcd4aa0) To check list of all goroutines which potentially can be running in onos-config, you can run the following command from dlv CLI: ```bash (dlv) goroutines Goroutine 1 - User: /usr/local/go/src/runtime/netpoll.go:182 internal/poll.runtime_pollWait (0x6a7b5e) Goroutine 2 - User: /usr/local/go/src/runtime/proc.go:302 runtime.gopark (0x6ae2c4) Goroutine 3 - User: /usr/local/go/src/runtime/proc.go:302 runtime.gopark (0x6ae2c4) Goroutine 4 - User: /usr/local/go/src/runtime/proc.go:302 runtime.gopark (0x6ae2c4) Goroutine 5 - User: /go/src/github.com/onosproject/onos-config/vendor/k8s.io/klog/klog.go:990 k8s.io/klog.( loggingT).flushDaemon (0x8227a3) Goroutine 6 - User: /go/src/github.com/onosproject/onos-config/vendor/github.com/golang/glog/glog.go:882 github.com/golang/glog.( loggingT).flushDaemon (0xca8b23) Goroutine 7 - User: /usr/local/go/src/runtime/proc.go:302 runtime.gopark (0x6ae2c4) Goroutine 8 - User: /usr/local/go/src/runtime/proc.go:302 runtime.gopark (0x6ae2c4) Goroutine 9 - User: /go/src/github.com/onosproject/onos-config/pkg/dispatcher/dispatcher.go:58 github.com/onosproject/onos-config/pkg/dispatcher.( Dispatcher).Listen (0x82a193) Goroutine 10 - User: /go/src/github.com/onosproject/onos-config/pkg/dispatcher/dispatcher.go:86 github.com/onosproject/onos-config/pkg/dispatcher.( Dispatcher).ListenOperationalState (0x82a96b) Goroutine 11 - User: /go/src/github.com/onosproject/onos-config/pkg/manager/manager.go:236 github.com/onosproject/onos-config/pkg/manager.listenOnResponseChannel (0xcdfd20) Goroutine 12 - User: /go/src/github.com/onosproject/onos-config/pkg/southbound/synchronizer/synchronizer.go:83 github.com/onosproject/onos-config/pkg/southbound/synchronizer.New (0xcd62a2) (thread 60) Goroutine 18 - User: /usr/local/go/src/runtime/lock_futex.go:228 runtime.notetsleepg (0x685a74) Goroutine 19 - User: /usr/local/go/src/runtime/proc.go:302 runtime.gopark (0x6ae2c4) Goroutine 20 - User: /usr/local/go/src/runtime/proc.go:302 runtime.gopark (0x6ae2c4) Goroutine 34 - User: /usr/local/go/src/runtime/lock_futex.go:228 runtime.notetsleepg (0x685a74) Goroutine 35 - User: /usr/local/go/src/runtime/proc.go:302 runtime.gopark (0x6ae2c4) Goroutine 83 - User: /usr/local/go/src/runtime/proc.go:302 runtime.gopark (0x6ae2c4) Goroutine 101 - User: /usr/local/go/src/runtime/netpoll.go:182 internal/poll.runtime_pollWait (0x6a7b5e) Goroutine 102 - User: /go/src/github.com/onosproject/onos-config/vendor/google.golang.org/grpc/internal/transport/controlbuf.go:317 google.golang.org/grpc/internal/transport.( controlBuffer).get (0xb54ae3) Goroutine 103 - User: /go/src/github.com/onosproject/onos-config/vendor/google.golang.org/grpc/stream.go:320 google.golang.org/grpc.newClientStream.func5 (0xc3492d) Goroutine 104 - User: /go/src/github.com/onosproject/onos-config/pkg/southbound/synchronizer/synchronizer.go:130 github.com/onosproject/onos-config/pkg/southbound/synchronizer.( Synchronizer).syncConfigEventsToDevice (0xcd72a5) Goroutine 105 - User: /go/src/github.com/onosproject/onos-config/vendor/google.golang.org/grpc/internal/transport/transport.go:267 google.golang.org/grpc/internal/transport.(*Stream).waitOnHeader (0xb7e542) ..... [49 goroutines] ``` Debug Your Code Line by Line After setting a breakpoint in a source file, you can execute your code line by line using next or n command from dlv CLI: For example: (dlv) n > github.com/onosproject/onos-config/pkg/southbound/synchronizer.New() /go/src/github.com/onosproject/onos-config/pkg/southbound/synchronizer/synchronizer.go:88 (PC: 0xcd64e9) (dlv) n > github.com/onosproject/onos-config/pkg/southbound/synchronizer.New() /go/src/github.com/onosproject/onos-config/pkg/southbound/synchronizer/synchronizer.go:89 (PC: 0xcd64f9) (dlv) n > github.com/onosproject/onos-config/pkg/southbound/synchronizer.New() /go/src/github.com/onosproject/onos-config/pkg/southbound/synchronizer/synchronizer.go:123 (PC: 0xcd65ec) (dlv) n Print Stack Trace To print stack trace, you can run stack command as follows: bash (dlv) stack 0 0x0000000000cd62a2 in github.com/onosproject/onos-config/pkg/southbound/synchronizer.New at /go/src/github.com/onosproject/onos-config/pkg/southbound/synchronizer/synchronizer.go:83 1 0x0000000000cd518e in github.com/onosproject/onos-config/pkg/southbound/synchronizer.Factory at /go/src/github.com/onosproject/onos-config/pkg/southbound/synchronizer/factory.go:49 2 0x00000000006dae71 in runtime.goexit at /usr/local/go/src/runtime/asm_amd64.s:1337","title":"Debug onos-config in Onit Using Delve"},{"location":"onos-config/docs/debugging/#debug-onos-config-in-onit-using-delve","text":"","title":"Debug onos-config in Onit Using Delve"},{"location":"onos-config/docs/debugging/#debugging-example-1-use-goland-ide-recommended","text":"In this example, we assume you already started an onit cluster. If you haven't done that yet, refer to testing for more details. First, you need to configure your Goland IDE to connect to the remote Delve debugger which is running in the onos-config pod. You can do that by going to Run | Edit Configurations\u2026 | + | Go Remote and configuring the host (in this example localhost ) and port (in this example port 40000 ) your remote debugger is listening on. To start debugging and open a debugger port to the given resource, you can run onit debug command. For example, to forwards a port to the debug port on the onos-config pod, run the following command: ```bash onit debug Forwarding from 127.0.0.1:40000 -> 40000 Forwarding from [::1]:40000 -> 40000 ``` To connect to the debugger using Goland IDE, select the configuration that you created in the first step and click on Debug button as follows: If your Goland IDE connects to the debug server which is running in onos-config pod successfully, then you should be able to see the following message in the logs: ```bash onit get logs .... 2019-07-22T15:09:27Z debug layer=debugger halting 2019-07-22T15:09:28Z debug layer=debugger continuing ``` Suppose we want to add a simulator and debug synchronizer code by setting a few breakpoints in different lines of its file as follows: As you can see above, after setting the breakpoints, you should be able to see some messages in the onos-config pod logs that confirm you set the breakpoints. When we add a simulator the Goland IDE hits the first breakpoint that was set. At this point you can go through the list of variables and goroutines using the debugger dashboard. Suppose we want to have tracepoints instead of breakpoints. Tracepoints don't cause the program execution to break and they can be useful when you need to inspect something, but not stop the program. To do that in Goland IDE, first set a breakpoint and then right-click on the breakpoint and unchecking \"Suspend\" as follows: You can also print a breakpoint hit message , print stack trace , and Evaluate and Log variables using tracepoints without pausing the program. For example, suppose we want to print the address of the device simulator in the synchronizer as we add a device simulator to the onit cluster:","title":"Debugging Example #1: Use Goland IDE (Recommended):"},{"location":"onos-config/docs/debugging/#debugging-example-2-use-simple-delve-client","text":"In this example, we assume you already started an onit cluster. If you haven't done that yet, refer to testing for more details. First, you need to install Delve on your machine to interact with the debugger in the onos-config pod. To make sure the debugger is installed successfully on your machine, run dlv command which should show its help. To start debugging and open a debugger port to the given resource, you can run onit debug command. For example, to forwards a port to the debug port on the onos-config pod, run the following command: ```bash onit debug Forwarding from 127.0.0.1:40000 -> 40000 Forwarding from [::1]:40000 -> 40000 ``` To connect to the debugger server which is running in the onos-config pod, run the following command from another terminal: ```bash dlv connect localhost:40000 Type 'help' for list of commands. (dlv) ``` If the dlv client connects to the server without any problems, you should be able to see the following message in the logs: bash > onit get logs onos-config-5d56898bdd-zrmt2 .... 2019-07-18T20:55:06Z debug layer=debugger halting To get list of sources that can be used for debugging, run the following command from the dlv CLI: bash (dlv) sources /go/src/github.com/onosproject/onos-config/cmd/onos-config/onos-config.go /go/src/github.com/onosproject/onos-config/modelplugin/Devicesim-1.0.0/devicesim_1_0_0/generated.go /go/src/github.com/onosproject/onos-config/modelplugin/Devicesim-1.0.0/modelmain.go /go/src/github.com/onosproject/onos-config/modelplugin/TestDevice-1.0.0/modelmain.go /go/src/github.com/onosproject/onos-config/modelplugin/TestDevice-1.0.0/testdevice_1_0_0/generated.go /go/src/github.com/onosproject/onos-config/modelplugin/TestDevice-2.0.0/modelmain.go /go/src/github.com/onosproject/onos-config/modelplugin/TestDevice-2.0.0/testdevice_2_0_0/generated.go /go/src/github.com/onosproject/onos-config/pkg/dispatcher/dispatcher.go /go/src/github.com/onosproject/onos-config/pkg/events/configevent.go /go/src/github.com/onosproject/onos-config/pkg/events/events.go /go/src/github.com/onosproject/onos-config/pkg/events/operationalevent.go /go/src/github.com/onosproject/onos-config/pkg/events/responseevent.go /go/src/github.com/onosproject/onos-config/pkg/events/topoevent.go /go/src/github.com/onosproject/onos-config/pkg/manager/getconfig.go /go/src/github.com/onosproject/onos-config/pkg/manager/manager.go /go/src/github.com/onosproject/onos-config/pkg/manager/rollbackconfig.go /go/src/github.com/onosproject/onos-config/pkg/manager/setconfig.go /go/src/github.com/onosproject/onos-config/pkg/modelregistry/modelregistry.go /go/src/github.com/onosproject/onos-config/pkg/northbound/admin/admin.go .... Suppose you want to set a breakpoint at line 83 of synchronizer . To do that, run the following command from dlv CLI: bash (dlv) break onosproject/onos-config/pkg/southbound/synchronizer/synchronizer.go:83 if you set it properly, you should be able to see a message like the following in the logs: bash onit get logs onos-config-5d56898bdd-zrmt2 ... 2019-07-18T21:03:24Z info layer=debugger created breakpoint: &api.Breakpoint{ID:2, Name:\"\", Addr:0xcd62a2, File:\"/go/src/github.com/onosproject/onos-config/pkg/southbound/synchronizer/synchronizer.go\", Line:83, FunctionName:\"github.com/onosproject/onos-config/pkg/southbound/synchronizer.New\", Cond:\"\", Tracepoint:false, TraceReturn:false, Goroutine:false, Stacktrace:0, Variables:[]string(nil), LoadArgs:(*api.LoadConfig)(nil), LoadLocals:(*api.LoadConfig)(nil), HitCount:map[string]uint64{}, TotalHitCount:0x0} Run continue from dlv CLI that runs until breakpoint as follows: bash (dlv) continue Then, add a device simulator using onit add simulator command. When onit cluster is trying to add a device simulator to the cluster, the debugger stops at the breakpoint and you should be able to see an output like the following from the dlv CLI: bash (dlv) continue > github.com/onosproject/onos-config/pkg/southbound/synchronizer.New() /go/src/github.com/onosproject/onos-config/pkg/southbound/synchronizer/synchronizer.go:83 (hits goroutine(9):1 total:1) (PC: 0xcd62a2) In addition, you can check the onos-config logs to make sure the program stops where you expect to stop: bash > onit get logs onos-config-5d56898bdd-zrmt2 2019-07-18T21:16:32Z debug layer=debugger continuing I0718 21:18:09.661372 32 dispatcher.go:103] Registering Device sim1 on channel 0xc000083920 and 0xc000083980 I0718 21:18:09.662158 32 synchronizer.go:64] Connecting to sim1:10161 over gNMI I0718 21:18:09.662369 32 clientManager.go:53] Loading default CA onfca I0718 21:18:09.662607 32 clientManager.go:60] Loading default certificates I0718 21:18:09.702593 32 synchronizer.go:72] sim1:10161 connected over gNMI Suppose we set another breakpoint at line 89 of synchronizer and run continue command from dlv CLI again. The output of dlv CLI and onos-config logs will be like the followings: ```bash (dlv) continue github.com/onosproject/onos-config/pkg/southbound/synchronizer.New() /go/src/github.com/onosproject/onos-config/pkg/southbound/synchronizer/synchronizer.go:89 (hits goroutine(9):1 total:1) (PC: 0xcd64f9) ``` ```bash onit get logs onos-config-5d56898bdd-zrmt2 ... 2019-07-18T21:25:21Z info layer=debugger created breakpoint: &api.Breakpoint{ID:3, Name:\"\", Addr:0xcd64f9, File:\"/go/src/github.com/onosproject/onos-config/pkg/southbound/synchronizer/synchronizer.go\", Line:89, FunctionName:\"github.com/onosproject/onos-config/pkg/southbound/synchronizer.New\", Cond:\"\", Tracepoint:false, TraceReturn:false, Goroutine:false, Stacktrace:0, Variables:[]string(nil), LoadArgs:( api.LoadConfig)(nil), LoadLocals:( api.LoadConfig)(nil), HitCount:map[string]uint64{}, TotalHitCount:0x0} 2019-07-18T21:26:51Z debug layer=debugger continuing I0718 21:26:51.518797 32 synchronizer.go:83] sim1:10161 capabilities supported_models: supported_models: supported_models: supported_models: supported_encodings:JSON supported_encodings:JSON_IETF gNMI_version:\"0.7.0\" I0718 21:26:51.519659 32 synchronizer.go:305] Getting saved config for sim1 ``` if you run continue again, it passes the breakpoint at line 89 and onos-config will keep running: bash > onit get logs onos-config-5d56898bdd-zrmt2 ... 2019-07-18T21:45:01Z debug layer=debugger continuing I0718 21:45:01.034584 32 synchronizer.go:89] sim1:10161 has no initial configuration I0718 21:45:01.053357 32 synchronizer.go:243] subscribe:<prefix:<> subscription:<path:<> sample_interval:15 heartbeat_interval:15 > subscription:<path:<> sample_interval:15 heartbeat_interval:15 > > At this point, you have two breakpoints in the synchronizer . To see list of your breakpoints, you can run breakpoints command from dlv CLI. bash (dlv) breakpoints Breakpoint runtime-fatal-throw at 0x6ab830 for runtime.fatalthrow() /usr/local/go/src/runtime/panic.go:663 (0) Breakpoint unrecovered-panic at 0x6ab8a0 for runtime.fatalpanic() /usr/local/go/src/runtime/panic.go:690 (0) print runtime.curg._panic.arg Breakpoint 4 at 0xcd62a2 for github.com/onosproject/onos-config/pkg/southbound/synchronizer.New() /go/src/github.com/onosproject/onos-config/pkg/southbound/synchronizer/synchronizer.go:83 (1) Breakpoint 5 at 0xcd64f9 for github.com/onosproject/onos-config/pkg/southbound/synchronizer.New() /go/src/github.com/onosproject/onos-config/pkg/southbound/synchronizer/synchronizer.go:89 (0) You can repeat the above steps by adding another simulator to onos-config and monitor dlv CLI and onos-config pod logs.","title":"Debugging. Example #2: Use Simple Delve Client:"},{"location":"onos-config/docs/debugging/#print-local-variables","text":"When you set breakpoints in a file, you can also print local variables as you go through the breakpoints. For example, look at the following piece of code from synchronizer : bash target := southbound.Target{} key, err := target.ConnectTarget(context, *sync.Device) sync.key = key Suppose we add a simulator and we would like to print the value of key when it passes this block of code. You can use print function from dlv CLI to print local variables in the code: bash (dlv) print key github.com/onosproject/onos-config/pkg/southbound.DeviceID { DeviceID: \"sim2:10161\",} or to print capResponse variable: bash (dlv) print capResponse *github.com/openconfig/gnmi/proto/gnmi.CapabilityResponse { SupportedModels: []*github.com/openconfig/gnmi/proto/gnmi.ModelData len: 4, cap: 4, [ *(*\"github.com/openconfig/gnmi/proto/gnmi.ModelData\")(0xc00042e280), *(*\"github.com/openconfig/gnmi/proto/gnmi.ModelData\")(0xc00042e2d0), *(*\"github.com/openconfig/gnmi/proto/gnmi.ModelData\")(0xc00042e320), *(*\"github.com/openconfig/gnmi/proto/gnmi.ModelData\")(0xc00042e370), ], SupportedEncodings: []github.com/openconfig/gnmi/proto/gnmi.Encoding len: 2, cap: 2, [Encoding_JSON (0),Encoding_JSON_IETF (4)], GNMIVersion: \"0.7.0\", Extension: []*github.com/openconfig/gnmi/proto/gnmi_ext.Extension len: 0, cap: 0, nil, XXX_NoUnkeyedLiteral: struct {} {}, XXX_unrecognized: []uint8 len: 0, cap: 0, nil, XXX_sizecache: 0,} You can also check the list of local variables using locals command from dlv CLI, for example: bash (dlv) locals sync = (\"*github.com/onosproject/onos-config/pkg/southbound/synchronizer.Synchronizer\")(0xc000368000) capResponse = (\"*github.com/openconfig/gnmi/proto/gnmi.CapabilityResponse\")(0xc000346d80) target = github.com/onosproject/onos-config/pkg/southbound.Target {Destination: (*\"github.com/openconfig/gnmi/client.Destination\")(0xc0004e00e0), Clt: github.com/onosproject/onos-config/pkg/southbound.GnmiClient(github.com/onosproject/onos-config/pkg/southbound.gnmiClientImpl) *(*\"github.com/onosproject/onos-config/pkg/southbound.GnmiClient\")(0xc0004e0130), Ctx: context.Context(*context.emptyCtx) ...} key = github.com/onosproject/onos-config/pkg/southbound.DeviceID {DeviceID: \"sim1:10161\"} err = error nil capErr = error nil","title":"Print Local Variables"},{"location":"onos-config/docs/debugging/#goroutines","text":"To check which goroutine is running when you are going through a piece of code using breakpoints, you can run the following command from dlv CLI: bash (dlv) goroutine Goroutine 12: Runtime: /go/src/github.com/onosproject/onos-config/pkg/southbound/synchronizer/synchronizer.go:83 github.com/onosproject/onos-config/pkg/southbound/synchronizer.New (0xcd62a2) User: /go/src/github.com/onosproject/onos-config/pkg/southbound/synchronizer/synchronizer.go:83 github.com/onosproject/onos-config/pkg/southbound/synchronizer.New (0xcd62a2) Go: /go/src/github.com/onosproject/onos-config/pkg/manager/manager.go:217 github.com/onosproject/onos-config/pkg/manager.(*Manager).Run (0xcdfb0c) Start: /go/src/github.com/onosproject/onos-config/pkg/southbound/synchronizer/factory.go:30 github.com/onosproject/onos-config/pkg/southbound/synchronizer.Factory (0xcd4aa0) To check list of all goroutines which potentially can be running in onos-config, you can run the following command from dlv CLI: ```bash (dlv) goroutines Goroutine 1 - User: /usr/local/go/src/runtime/netpoll.go:182 internal/poll.runtime_pollWait (0x6a7b5e) Goroutine 2 - User: /usr/local/go/src/runtime/proc.go:302 runtime.gopark (0x6ae2c4) Goroutine 3 - User: /usr/local/go/src/runtime/proc.go:302 runtime.gopark (0x6ae2c4) Goroutine 4 - User: /usr/local/go/src/runtime/proc.go:302 runtime.gopark (0x6ae2c4) Goroutine 5 - User: /go/src/github.com/onosproject/onos-config/vendor/k8s.io/klog/klog.go:990 k8s.io/klog.( loggingT).flushDaemon (0x8227a3) Goroutine 6 - User: /go/src/github.com/onosproject/onos-config/vendor/github.com/golang/glog/glog.go:882 github.com/golang/glog.( loggingT).flushDaemon (0xca8b23) Goroutine 7 - User: /usr/local/go/src/runtime/proc.go:302 runtime.gopark (0x6ae2c4) Goroutine 8 - User: /usr/local/go/src/runtime/proc.go:302 runtime.gopark (0x6ae2c4) Goroutine 9 - User: /go/src/github.com/onosproject/onos-config/pkg/dispatcher/dispatcher.go:58 github.com/onosproject/onos-config/pkg/dispatcher.( Dispatcher).Listen (0x82a193) Goroutine 10 - User: /go/src/github.com/onosproject/onos-config/pkg/dispatcher/dispatcher.go:86 github.com/onosproject/onos-config/pkg/dispatcher.( Dispatcher).ListenOperationalState (0x82a96b) Goroutine 11 - User: /go/src/github.com/onosproject/onos-config/pkg/manager/manager.go:236 github.com/onosproject/onos-config/pkg/manager.listenOnResponseChannel (0xcdfd20) Goroutine 12 - User: /go/src/github.com/onosproject/onos-config/pkg/southbound/synchronizer/synchronizer.go:83 github.com/onosproject/onos-config/pkg/southbound/synchronizer.New (0xcd62a2) (thread 60) Goroutine 18 - User: /usr/local/go/src/runtime/lock_futex.go:228 runtime.notetsleepg (0x685a74) Goroutine 19 - User: /usr/local/go/src/runtime/proc.go:302 runtime.gopark (0x6ae2c4) Goroutine 20 - User: /usr/local/go/src/runtime/proc.go:302 runtime.gopark (0x6ae2c4) Goroutine 34 - User: /usr/local/go/src/runtime/lock_futex.go:228 runtime.notetsleepg (0x685a74) Goroutine 35 - User: /usr/local/go/src/runtime/proc.go:302 runtime.gopark (0x6ae2c4) Goroutine 83 - User: /usr/local/go/src/runtime/proc.go:302 runtime.gopark (0x6ae2c4) Goroutine 101 - User: /usr/local/go/src/runtime/netpoll.go:182 internal/poll.runtime_pollWait (0x6a7b5e) Goroutine 102 - User: /go/src/github.com/onosproject/onos-config/vendor/google.golang.org/grpc/internal/transport/controlbuf.go:317 google.golang.org/grpc/internal/transport.( controlBuffer).get (0xb54ae3) Goroutine 103 - User: /go/src/github.com/onosproject/onos-config/vendor/google.golang.org/grpc/stream.go:320 google.golang.org/grpc.newClientStream.func5 (0xc3492d) Goroutine 104 - User: /go/src/github.com/onosproject/onos-config/pkg/southbound/synchronizer/synchronizer.go:130 github.com/onosproject/onos-config/pkg/southbound/synchronizer.( Synchronizer).syncConfigEventsToDevice (0xcd72a5) Goroutine 105 - User: /go/src/github.com/onosproject/onos-config/vendor/google.golang.org/grpc/internal/transport/transport.go:267 google.golang.org/grpc/internal/transport.(*Stream).waitOnHeader (0xb7e542) ..... [49 goroutines] ```","title":"Goroutines"},{"location":"onos-config/docs/debugging/#debug-your-code-line-by-line","text":"After setting a breakpoint in a source file, you can execute your code line by line using next or n command from dlv CLI: For example: (dlv) n > github.com/onosproject/onos-config/pkg/southbound/synchronizer.New() /go/src/github.com/onosproject/onos-config/pkg/southbound/synchronizer/synchronizer.go:88 (PC: 0xcd64e9) (dlv) n > github.com/onosproject/onos-config/pkg/southbound/synchronizer.New() /go/src/github.com/onosproject/onos-config/pkg/southbound/synchronizer/synchronizer.go:89 (PC: 0xcd64f9) (dlv) n > github.com/onosproject/onos-config/pkg/southbound/synchronizer.New() /go/src/github.com/onosproject/onos-config/pkg/southbound/synchronizer/synchronizer.go:123 (PC: 0xcd65ec) (dlv) n","title":"Debug Your Code Line by Line"},{"location":"onos-config/docs/debugging/#print-stack-trace","text":"To print stack trace, you can run stack command as follows: bash (dlv) stack 0 0x0000000000cd62a2 in github.com/onosproject/onos-config/pkg/southbound/synchronizer.New at /go/src/github.com/onosproject/onos-config/pkg/southbound/synchronizer/synchronizer.go:83 1 0x0000000000cd518e in github.com/onosproject/onos-config/pkg/southbound/synchronizer.Factory at /go/src/github.com/onosproject/onos-config/pkg/southbound/synchronizer/factory.go:49 2 0x00000000006dae71 in runtime.goexit at /usr/local/go/src/runtime/asm_amd64.s:1337","title":"Print Stack Trace"},{"location":"onos-config/docs/deployment/","text":"Deploying onos-config One of the goals of the onos-config project is to provide simple deployment options that integrate with modern technologies. Deployment configurations can be found in the /deployments folder in this repository. Deploying on Kubernetes with Helm Helm is a package manager for Kubernetes that allows projects to provide a collection of templates for all the resources needed to deploy on k8s. ONOS Config provides a Helm chart for deploying a cluster for development and testing. In the future, this chart will be extended for production use. Resources The Helm chart provides resources for deploying the config service and accessing it over the network, both inside and outside the k8s cluster: * Deployment - Provides a template for ONOS Config pods * ConfigMap - Provides test configurations for the application * Service - Exposes ONOS Config to other applications on the network * Secret - Provides TLS certificates for end-to-end encryption * Ingress - Optionally provides support for external load balancing Local Deployment Setup To deploy the Helm chart locally, install Minikube and Helm . On OSX, this can be done using Brew : > brew cask install minikube > brew install kubernetes-helm You will also need VirtualBox 6.0 or higher and Docker to build and deploy an image. * VirtualBox installation instructions * Docker installation instructions On Linux, users have additional options for installing local k8s clusters. Once Minikube has been installed, start it with minikube start . If deploying an ingress to access the service from outside the cluster, be sure to give enough memory to the VM to run NGINX . > minikube start --memory=4096 --disk-size=50g --cpus=4 Once Minikube has been started, set your Docker environment to the Minikube Docker daemon and build the ONOS Config image: > eval $(minikube docker-env) > make Helm requires a special pod called Tiller to be running inside the k8s cluster for deployment management. Before using Helm you must deploy the Tiller pod via helm init : > helm init Wait for the Tiller pod to transition to the ready state before proceeding: > kubectl get pods -n kube-system NAME READY STATUS RESTARTS AGE ... tiller-deploy-659d9559f5-k4v6p 1/1 Running 0 65s The onos-config Helm charts also support exposing the config service externally via an [ Ingress ] resource. But to support ingress, the Kubernetes cluster must first be configured with an ingress controller . Fortunately, Minikube ships with the NGINX ingress controller provided as an addon, so to enable ingress via NGINX simply enable the ingress addon: > minikube addons enable ingress Again, ensure the nginx-ingress-controller-x pod in the kube-system namespace is running and ready: > kubectl get pods -n kube-system NAME READY STATUS RESTARTS AGE ... nginx-ingress-controller-586cdc477c-whbx5 1/1 Running 0 7m52s Installing the Chart To install the chart, simply run helm install deployments/helm/onos-config from the root directory of this project: > helm install deployments/helm/onos-config NAME: jumpy-tortoise LAST DEPLOYED: Tue May 14 18:56:39 2019 NAMESPACE: default STATUS: DEPLOYED RESOURCES: ==> v1/Service NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE jumpy-tortoise-onos-config NodePort 10.106.9.103 <none> 5150:32271/TCP 0s ==> v1/Deployment NAME DESIRED CURRENT UP-TO-DATE AVAILABLE AGE jumpy-tortoise-onos-config 1 1 1 0 0s ==> v1beta1/Ingress NAME HOSTS ADDRESS PORTS AGE jumpy-tortoise-onos-config-ingress config.onosproject.org 80, 443 0s ==> v1/Pod(related) NAME READY STATUS RESTARTS AGE jumpy-tortoise-onos-config-655964cbf5-tkcfb 0/1 ContainerCreating 0 0s ==> v1/Secret NAME TYPE DATA AGE jumpy-tortoise-onos-config-secret Opaque 4 0s ==> v1/ConfigMap NAME DATA AGE jumpy-tortoise-onos-config-config 5 0s helm install assigns a unique name to the chart and displays all the k8s resources that were created by it. To list the charts that are installed and view their statuses, run helm ls : > helm ls NAME REVISION UPDATED STATUS CHART APP VERSION NAMESPACE ... jumpy-tortoise 1 Tue May 14 18:56:39 2019 DEPLOYED onos-config-0.0.1 0.0.1 default To view the pods that are deployed, run kubectl get pods : > kubectl get pods NAME READY STATUS RESTARTS AGE ... jumpy-tortoise-onos-config-655964cbf5-tkcfb 1/1 Running 0 52s You can view more detailed information about the pod and other resources by running kubectl describe : > kubectl describe pod jumpy-tortoise-onos-config-655964cbf5-tkcfb Name: jumpy-tortoise-onos-config-655964cbf5-tkcfb Namespace: default Priority: 0 PriorityClassName: <none> Node: minikube/10.0.2.15 Start Time: Tue, 14 May 2019 18:56:39 -0700 ... The onos-config pods are reached through a Service which load balances requests to the application. To view the services, run kubectl get services : > kubectl get svc NAME DATA AGE ... jumpy-tortoise-onos-config-config 5 86s The application's configuration is stored in a ConfigMap which can be viewed by running kubectl get configmaps : > kubectl get cm NAME DATA AGE ... jumpy-tortoise-onos-config-config 5 97s And TLS keys and certs are stored in a Secret resource: > kubectl get secrets NAME TYPE DATA AGE ... jumpy-tortoise-onos-config-secret Opaque 4 109s Ingress You can optionally enable ingress by overriding ingress.enabled . Note that you must have an ingress controller installed/enabled as described above: > helm install \\ -n onos-config \\ --set ingress.enabled=true \\ deployments/helm/onos-config By default, the ingress controller uses the self-signed certificates that ship with the chart to provide end-to-end routing, load balancing, and encryption, making the onos-config services accessible from outside the k8s cluster. The default certificates expect the service to be reached through the config.onosproject.org domain. Thus, to connect to the service through the ingress, you must configure /etc/hosts to point to the load balancer's IP: 192.168.99.102 config.onosproject.org The IP address of the ingress may differ depending on the environment. In clustered environments, the ingress IP is typically read from the ingress resource: > kubectl get ingress NAME HOSTS ADDRESS PORTS AGE onos-config-onos-config-ingress config.onosproject.org 10.0.2.15 80, 443 76m However, since Minikube runs in a VM, the ingress must be reached through the Minikube VM's IP which can be found via the minikube ip command: LBIP=$(minikube ip) In clustered environments, the ingress IP can be retrieved from the ingress metadata: > kubectl get ingress NAME HOSTS ADDRESS PORTS AGE onos-config-onos-config-ingress config.onosproject.org 10.0.2.15 80, 443 76m Once you've located the ingress IP address and configured /etc/hosts , you can connect to the onos-config service via the ingress load balancer: > onos config --address=config.onosproject.org:443 get changes | Note that the onos command-line client must be built or installed as described in the CLI documentation . Clients must connect through the HTTPS port using the certificates with which the ingress was configured. Currently, the certificates used by the Helm chart can be found in the deployments/helm/onos-config/files/certs directory. Command-line shell container For containerized environments like Kubernetes, a Docker image onosproject/onos-cli is provided. This image is built as part of the normal build. To use the CLI in Kubernetes, run the onosproject/onos-cli image in a single pod deployment: > kubectl run onos-cli --rm -it --image onosproject/onos-cli:latest --image-pull-policy \"IfNotPresent\" --restart \"Never\" This command will run the CLI image as a Deployment and log into the bash shell. Once you've joined the container, you can connect to the onos-config server by running: > onos config config set address something-else-onos-config:5150 something-else-onos-config:5150 Note that this is only necessary if you named your deployment something else than onos-config . Once the controller address is set, you should be able to execute any of the ONOS commands without specifying the controller address each time. See the onos-cli for the full usage information. Once the shell is exited, the Deployment will be deleted. Deploying the device simulator ONOS Config provides a device simulator for end-to-end testing. As with the onos-config app, a Helm chart is provided for deployment in Kubernetes . Each chart instance deploys a single simulated device Pod and a Service through which the simulator can be accessed. The onos-config chart can then be configured to connect to the devices in k8s. Device simulators can be deployed using the deployments/helm/device-simulator chart: > helm install -n device-1 deployments/helm/device-simulator NAME: device-1 LAST DEPLOYED: Sun May 12 01:16:41 2019 NAMESPACE: default STATUS: DEPLOYED RESOURCES: ==> v1/ConfigMap NAME DATA AGE device-1-device-simulator-config 1 1s ==> v1/Service NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE device-1-device-simulator ClusterIP 10.110.252.69 <none> 10161/TCP 1s ==> v1/Pod NAME READY STATUS RESTARTS AGE device-1-device-simulator 0/1 ContainerCreating 0 1s The device-simulator chart deploys a single Pod containing the device simulator with a Service through which it can be accessed. The device simulator's service can be seen by running the kubectl get services command: > kubectl get svc NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE device-1-device-simulator ClusterIP 10.106.28.52 <none> 10161/TCP 25m onos-config pods can be connected to the device through this service by passing the service name and port to the onos-config Helm chart via the devices option: > helm install \\ -n onos-config \\ --set ingress.enabled=true \\ --set devices='{device-1-device-simulator}' \\ deployments/helm/onos-config You can verify that the onos-config pods were connected to the device by checking the logs: > kubectl get pods device-1-device-simulator 1/1 Running 0 86s onos-config-onos-config-6f476ddc95-rgpgs 1/1 Running 0 16s > kubectl logs onos-config-onos-config-6f476ddc95-rgpgs 2019/05/15 07:07:36 Creating Manager 2019/05/15 07:07:36 Starting Manager 2019/05/15 07:07:36 Connecting to device-1-device-simulator:10161 over gNMI 2019/05/15 07:07:36 Could not get target Client for {device-1-device-simulator:10161} does not exist, create first 2019/05/15 07:07:36 Loading default CA onfca 2019/05/15 07:07:36 Event listener initialized 2019/05/15 07:07:36 Loading default certificates 2019/05/15 07:07:36 device-1-device-simulator:10161 Connected over gNMI 2019/05/15 07:07:36 device-1-device-simulator:10161 Capabilities supported_models:<name:\"openconfig-interfaces\" organization:\"OpenConfig working group\" version:\"2.0.0\" > supported_models:<name:\"openconfig-openflow\" organization:\"OpenConfig working group\" version:\"0.1.0\" > supported_models:<name:\"openconfig-platform\" organization:\"OpenConfig working group\" version:\"0.5.0\" > supported_models:<name:\"openconfig-system\" organization:\"OpenConfig working group\" version:\"0.2.0\" > supported_encodings:JSON supported_encodings:JSON_IETF gNMI_version:\"0.7.0\" Once onos-config has been deployed and connected to the device service, the northbound API can be used to query and update the device configuration. This is done by setting the -address argument in the gnmi_cli to the ingress host:port - i.e. config.onosproject.org:443 - and identifying the device in the update target . Devices again are identified by the name of their associated service and port: > gnmi_cli -set \\ -address config.onosproject.org:443 \\ -proto \"update: <path: <target: 'device-1-device-simulator', elem: <name: 'system'> elem: <name: 'clock' > elem: <name: 'config'> elem: <name: 'timezone-name'>> val: <string_val: 'Europe/Dublin'>>\" \\ -timeout 5s \\ -client_crt deployments/helm/onos-config/files/certs/tls.crt \\ -client_key deployments/helm/onos-config/files/certs/tls.key \\ -ca_crt deployments/helm/onos-config/files/certs/tls.cacrt \\ -alsologtostderr response: < path: < elem: < name: \"/system/clock/config/timezone-name\" > target: \"device-1-device-simulator\" > op: UPDATE > timestamp: 1557904258 The client must connect through the HTTPS port using the certificates with which the ingress was configured. The default certificates provided by the onos-config Helm chart can be found in the deployments/helm/onos-config/files/certs directory. Once you have modified the device, you can verify that onos-config handled the update successfully by checking the onos-config logs: > kubectl logs onos-config-onos-config-6f476ddc95-rgpgs ... 2019/05/15 07:07:36 device-1-device-simulator:10161 Connected over gNMI 2019/05/15 07:07:36 device-1-device-simulator:10161 Capabilities supported_models:<name:\"openconfig-interfaces\" organization:\"OpenConfig working group\" version:\"2.0.0\" > supported_models:<name:\"openconfig-openflow\" organization:\"OpenConfig working group\" version:\"0.1.0\" > supported_models:<name:\"openconfig-platform\" organization:\"OpenConfig working group\" version:\"0.5.0\" > supported_models:<name:\"openconfig-system\" organization:\"OpenConfig working group\" version:\"0.2.0\" > supported_encodings:JSON supported_encodings:JSON_IETF gNMI_version:\"0.7.0\" 2019/05/15 07:10:58 Added change M/IUW67JikD+V0clLfTEz5lTm6s= to ChangeStore (in memory) 2019/05/15 07:10:58 Change formatted to gNMI setRequest update:<path:<elem:<name:\"system\" > elem:<name:\"clock\" > elem:<name:\"config\" > elem:<name:\"timezone-name\" > > val:<string_val:\"Europe/Dublin\" > > 2019/05/15 07:10:58 device-1-device-simulator:10161 SetResponse response:<path:<elem:<name:\"system\" > elem:<name:\"clock\" > elem:<name:\"config\" > elem:<name:\"timezone-name\" > > op:UPDATE > If the update was successful, you should be able to read the updated state of the device through the northbound API: > gnmi_cli -get \\ -address config.onosproject.org:443 \\ -proto \"path: <target: 'device-1-device-simulator', elem: <name: 'system'> elem: <name: 'clock' > elem:<name:'config'> elem: <name: 'timezone-name'>>\" \\ -timeout 5s \\ -client_crt deployments/helm/onos-config/files/certs/tls.crt \\ -client_key deployments/helm/onos-config/files/certs/tls.key \\ -ca_crt deployments/helm/onos-config/files/certs/tls.cacrt \\ -alsologtostderr notification: < timestamp: 1557856109 update: < path: < elem: < name: \"system\" > elem: < name: \"clock\" > elem: < name: \"config\" > elem: < name: \"timezone-name\" > target: \"device-1-device-simulator\" > val: < ascii_val: \"Europe/Dublin\" > > > Deploying multiple simulators To deploy onos-config with multiple simulators, simply install the simulator chart n times to create n devices, each with a unique name: > helm install -n device-1 deployments/helm/device-simulator > helm install -n device-2 deployments/helm/device-simulator > helm install -n device-3 deployments/helm/device-simulator Then pass a comma-separated list of device services to configure the onos-config pods to connect to each of the devices: > kubectl get svc NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE device-1-device-simulator ClusterIP 10.106.28.52 <none> 10161/TCP 49s device-2-device-simulator ClusterIP 10.98.157.220 <none> 10161/TCP 23s device-3-device-simulator ClusterIP 10.110.71.250 <none> 10161/TCP 17s > helm install \\ -n onos-config \\ --set ingress.enabled=true \\ --set devices='{device-1-device-simulator,device-2-device-simulator,device-3-device-simulator}' \\ deployments/helm/onos-config","title":"Deploying onos-config"},{"location":"onos-config/docs/deployment/#deploying-onos-config","text":"One of the goals of the onos-config project is to provide simple deployment options that integrate with modern technologies. Deployment configurations can be found in the /deployments folder in this repository.","title":"Deploying onos-config"},{"location":"onos-config/docs/deployment/#deploying-on-kubernetes-with-helm","text":"Helm is a package manager for Kubernetes that allows projects to provide a collection of templates for all the resources needed to deploy on k8s. ONOS Config provides a Helm chart for deploying a cluster for development and testing. In the future, this chart will be extended for production use.","title":"Deploying on Kubernetes with Helm"},{"location":"onos-config/docs/deployment/#resources","text":"The Helm chart provides resources for deploying the config service and accessing it over the network, both inside and outside the k8s cluster: * Deployment - Provides a template for ONOS Config pods * ConfigMap - Provides test configurations for the application * Service - Exposes ONOS Config to other applications on the network * Secret - Provides TLS certificates for end-to-end encryption * Ingress - Optionally provides support for external load balancing","title":"Resources"},{"location":"onos-config/docs/deployment/#local-deployment-setup","text":"To deploy the Helm chart locally, install Minikube and Helm . On OSX, this can be done using Brew : > brew cask install minikube > brew install kubernetes-helm You will also need VirtualBox 6.0 or higher and Docker to build and deploy an image. * VirtualBox installation instructions * Docker installation instructions On Linux, users have additional options for installing local k8s clusters. Once Minikube has been installed, start it with minikube start . If deploying an ingress to access the service from outside the cluster, be sure to give enough memory to the VM to run NGINX . > minikube start --memory=4096 --disk-size=50g --cpus=4 Once Minikube has been started, set your Docker environment to the Minikube Docker daemon and build the ONOS Config image: > eval $(minikube docker-env) > make Helm requires a special pod called Tiller to be running inside the k8s cluster for deployment management. Before using Helm you must deploy the Tiller pod via helm init : > helm init Wait for the Tiller pod to transition to the ready state before proceeding: > kubectl get pods -n kube-system NAME READY STATUS RESTARTS AGE ... tiller-deploy-659d9559f5-k4v6p 1/1 Running 0 65s The onos-config Helm charts also support exposing the config service externally via an [ Ingress ] resource. But to support ingress, the Kubernetes cluster must first be configured with an ingress controller . Fortunately, Minikube ships with the NGINX ingress controller provided as an addon, so to enable ingress via NGINX simply enable the ingress addon: > minikube addons enable ingress Again, ensure the nginx-ingress-controller-x pod in the kube-system namespace is running and ready: > kubectl get pods -n kube-system NAME READY STATUS RESTARTS AGE ... nginx-ingress-controller-586cdc477c-whbx5 1/1 Running 0 7m52s","title":"Local Deployment Setup"},{"location":"onos-config/docs/deployment/#installing-the-chart","text":"To install the chart, simply run helm install deployments/helm/onos-config from the root directory of this project: > helm install deployments/helm/onos-config NAME: jumpy-tortoise LAST DEPLOYED: Tue May 14 18:56:39 2019 NAMESPACE: default STATUS: DEPLOYED RESOURCES: ==> v1/Service NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE jumpy-tortoise-onos-config NodePort 10.106.9.103 <none> 5150:32271/TCP 0s ==> v1/Deployment NAME DESIRED CURRENT UP-TO-DATE AVAILABLE AGE jumpy-tortoise-onos-config 1 1 1 0 0s ==> v1beta1/Ingress NAME HOSTS ADDRESS PORTS AGE jumpy-tortoise-onos-config-ingress config.onosproject.org 80, 443 0s ==> v1/Pod(related) NAME READY STATUS RESTARTS AGE jumpy-tortoise-onos-config-655964cbf5-tkcfb 0/1 ContainerCreating 0 0s ==> v1/Secret NAME TYPE DATA AGE jumpy-tortoise-onos-config-secret Opaque 4 0s ==> v1/ConfigMap NAME DATA AGE jumpy-tortoise-onos-config-config 5 0s helm install assigns a unique name to the chart and displays all the k8s resources that were created by it. To list the charts that are installed and view their statuses, run helm ls : > helm ls NAME REVISION UPDATED STATUS CHART APP VERSION NAMESPACE ... jumpy-tortoise 1 Tue May 14 18:56:39 2019 DEPLOYED onos-config-0.0.1 0.0.1 default To view the pods that are deployed, run kubectl get pods : > kubectl get pods NAME READY STATUS RESTARTS AGE ... jumpy-tortoise-onos-config-655964cbf5-tkcfb 1/1 Running 0 52s You can view more detailed information about the pod and other resources by running kubectl describe : > kubectl describe pod jumpy-tortoise-onos-config-655964cbf5-tkcfb Name: jumpy-tortoise-onos-config-655964cbf5-tkcfb Namespace: default Priority: 0 PriorityClassName: <none> Node: minikube/10.0.2.15 Start Time: Tue, 14 May 2019 18:56:39 -0700 ... The onos-config pods are reached through a Service which load balances requests to the application. To view the services, run kubectl get services : > kubectl get svc NAME DATA AGE ... jumpy-tortoise-onos-config-config 5 86s The application's configuration is stored in a ConfigMap which can be viewed by running kubectl get configmaps : > kubectl get cm NAME DATA AGE ... jumpy-tortoise-onos-config-config 5 97s And TLS keys and certs are stored in a Secret resource: > kubectl get secrets NAME TYPE DATA AGE ... jumpy-tortoise-onos-config-secret Opaque 4 109s","title":"Installing the Chart"},{"location":"onos-config/docs/deployment/#ingress","text":"You can optionally enable ingress by overriding ingress.enabled . Note that you must have an ingress controller installed/enabled as described above: > helm install \\ -n onos-config \\ --set ingress.enabled=true \\ deployments/helm/onos-config By default, the ingress controller uses the self-signed certificates that ship with the chart to provide end-to-end routing, load balancing, and encryption, making the onos-config services accessible from outside the k8s cluster. The default certificates expect the service to be reached through the config.onosproject.org domain. Thus, to connect to the service through the ingress, you must configure /etc/hosts to point to the load balancer's IP: 192.168.99.102 config.onosproject.org The IP address of the ingress may differ depending on the environment. In clustered environments, the ingress IP is typically read from the ingress resource: > kubectl get ingress NAME HOSTS ADDRESS PORTS AGE onos-config-onos-config-ingress config.onosproject.org 10.0.2.15 80, 443 76m However, since Minikube runs in a VM, the ingress must be reached through the Minikube VM's IP which can be found via the minikube ip command: LBIP=$(minikube ip) In clustered environments, the ingress IP can be retrieved from the ingress metadata: > kubectl get ingress NAME HOSTS ADDRESS PORTS AGE onos-config-onos-config-ingress config.onosproject.org 10.0.2.15 80, 443 76m Once you've located the ingress IP address and configured /etc/hosts , you can connect to the onos-config service via the ingress load balancer: > onos config --address=config.onosproject.org:443 get changes | Note that the onos command-line client must be built or installed as described in the CLI documentation . Clients must connect through the HTTPS port using the certificates with which the ingress was configured. Currently, the certificates used by the Helm chart can be found in the deployments/helm/onos-config/files/certs directory.","title":"Ingress"},{"location":"onos-config/docs/deployment/#command-line-shell-container","text":"For containerized environments like Kubernetes, a Docker image onosproject/onos-cli is provided. This image is built as part of the normal build. To use the CLI in Kubernetes, run the onosproject/onos-cli image in a single pod deployment: > kubectl run onos-cli --rm -it --image onosproject/onos-cli:latest --image-pull-policy \"IfNotPresent\" --restart \"Never\" This command will run the CLI image as a Deployment and log into the bash shell. Once you've joined the container, you can connect to the onos-config server by running: > onos config config set address something-else-onos-config:5150 something-else-onos-config:5150 Note that this is only necessary if you named your deployment something else than onos-config . Once the controller address is set, you should be able to execute any of the ONOS commands without specifying the controller address each time. See the onos-cli for the full usage information. Once the shell is exited, the Deployment will be deleted.","title":"Command-line shell container"},{"location":"onos-config/docs/deployment/#deploying-the-device-simulator","text":"ONOS Config provides a device simulator for end-to-end testing. As with the onos-config app, a Helm chart is provided for deployment in Kubernetes . Each chart instance deploys a single simulated device Pod and a Service through which the simulator can be accessed. The onos-config chart can then be configured to connect to the devices in k8s. Device simulators can be deployed using the deployments/helm/device-simulator chart: > helm install -n device-1 deployments/helm/device-simulator NAME: device-1 LAST DEPLOYED: Sun May 12 01:16:41 2019 NAMESPACE: default STATUS: DEPLOYED RESOURCES: ==> v1/ConfigMap NAME DATA AGE device-1-device-simulator-config 1 1s ==> v1/Service NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE device-1-device-simulator ClusterIP 10.110.252.69 <none> 10161/TCP 1s ==> v1/Pod NAME READY STATUS RESTARTS AGE device-1-device-simulator 0/1 ContainerCreating 0 1s The device-simulator chart deploys a single Pod containing the device simulator with a Service through which it can be accessed. The device simulator's service can be seen by running the kubectl get services command: > kubectl get svc NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE device-1-device-simulator ClusterIP 10.106.28.52 <none> 10161/TCP 25m onos-config pods can be connected to the device through this service by passing the service name and port to the onos-config Helm chart via the devices option: > helm install \\ -n onos-config \\ --set ingress.enabled=true \\ --set devices='{device-1-device-simulator}' \\ deployments/helm/onos-config You can verify that the onos-config pods were connected to the device by checking the logs: > kubectl get pods device-1-device-simulator 1/1 Running 0 86s onos-config-onos-config-6f476ddc95-rgpgs 1/1 Running 0 16s > kubectl logs onos-config-onos-config-6f476ddc95-rgpgs 2019/05/15 07:07:36 Creating Manager 2019/05/15 07:07:36 Starting Manager 2019/05/15 07:07:36 Connecting to device-1-device-simulator:10161 over gNMI 2019/05/15 07:07:36 Could not get target Client for {device-1-device-simulator:10161} does not exist, create first 2019/05/15 07:07:36 Loading default CA onfca 2019/05/15 07:07:36 Event listener initialized 2019/05/15 07:07:36 Loading default certificates 2019/05/15 07:07:36 device-1-device-simulator:10161 Connected over gNMI 2019/05/15 07:07:36 device-1-device-simulator:10161 Capabilities supported_models:<name:\"openconfig-interfaces\" organization:\"OpenConfig working group\" version:\"2.0.0\" > supported_models:<name:\"openconfig-openflow\" organization:\"OpenConfig working group\" version:\"0.1.0\" > supported_models:<name:\"openconfig-platform\" organization:\"OpenConfig working group\" version:\"0.5.0\" > supported_models:<name:\"openconfig-system\" organization:\"OpenConfig working group\" version:\"0.2.0\" > supported_encodings:JSON supported_encodings:JSON_IETF gNMI_version:\"0.7.0\" Once onos-config has been deployed and connected to the device service, the northbound API can be used to query and update the device configuration. This is done by setting the -address argument in the gnmi_cli to the ingress host:port - i.e. config.onosproject.org:443 - and identifying the device in the update target . Devices again are identified by the name of their associated service and port: > gnmi_cli -set \\ -address config.onosproject.org:443 \\ -proto \"update: <path: <target: 'device-1-device-simulator', elem: <name: 'system'> elem: <name: 'clock' > elem: <name: 'config'> elem: <name: 'timezone-name'>> val: <string_val: 'Europe/Dublin'>>\" \\ -timeout 5s \\ -client_crt deployments/helm/onos-config/files/certs/tls.crt \\ -client_key deployments/helm/onos-config/files/certs/tls.key \\ -ca_crt deployments/helm/onos-config/files/certs/tls.cacrt \\ -alsologtostderr response: < path: < elem: < name: \"/system/clock/config/timezone-name\" > target: \"device-1-device-simulator\" > op: UPDATE > timestamp: 1557904258 The client must connect through the HTTPS port using the certificates with which the ingress was configured. The default certificates provided by the onos-config Helm chart can be found in the deployments/helm/onos-config/files/certs directory. Once you have modified the device, you can verify that onos-config handled the update successfully by checking the onos-config logs: > kubectl logs onos-config-onos-config-6f476ddc95-rgpgs ... 2019/05/15 07:07:36 device-1-device-simulator:10161 Connected over gNMI 2019/05/15 07:07:36 device-1-device-simulator:10161 Capabilities supported_models:<name:\"openconfig-interfaces\" organization:\"OpenConfig working group\" version:\"2.0.0\" > supported_models:<name:\"openconfig-openflow\" organization:\"OpenConfig working group\" version:\"0.1.0\" > supported_models:<name:\"openconfig-platform\" organization:\"OpenConfig working group\" version:\"0.5.0\" > supported_models:<name:\"openconfig-system\" organization:\"OpenConfig working group\" version:\"0.2.0\" > supported_encodings:JSON supported_encodings:JSON_IETF gNMI_version:\"0.7.0\" 2019/05/15 07:10:58 Added change M/IUW67JikD+V0clLfTEz5lTm6s= to ChangeStore (in memory) 2019/05/15 07:10:58 Change formatted to gNMI setRequest update:<path:<elem:<name:\"system\" > elem:<name:\"clock\" > elem:<name:\"config\" > elem:<name:\"timezone-name\" > > val:<string_val:\"Europe/Dublin\" > > 2019/05/15 07:10:58 device-1-device-simulator:10161 SetResponse response:<path:<elem:<name:\"system\" > elem:<name:\"clock\" > elem:<name:\"config\" > elem:<name:\"timezone-name\" > > op:UPDATE > If the update was successful, you should be able to read the updated state of the device through the northbound API: > gnmi_cli -get \\ -address config.onosproject.org:443 \\ -proto \"path: <target: 'device-1-device-simulator', elem: <name: 'system'> elem: <name: 'clock' > elem:<name:'config'> elem: <name: 'timezone-name'>>\" \\ -timeout 5s \\ -client_crt deployments/helm/onos-config/files/certs/tls.crt \\ -client_key deployments/helm/onos-config/files/certs/tls.key \\ -ca_crt deployments/helm/onos-config/files/certs/tls.cacrt \\ -alsologtostderr notification: < timestamp: 1557856109 update: < path: < elem: < name: \"system\" > elem: < name: \"clock\" > elem: < name: \"config\" > elem: < name: \"timezone-name\" > target: \"device-1-device-simulator\" > val: < ascii_val: \"Europe/Dublin\" > > >","title":"Deploying the device simulator"},{"location":"onos-config/docs/deployment/#deploying-multiple-simulators","text":"To deploy onos-config with multiple simulators, simply install the simulator chart n times to create n devices, each with a unique name: > helm install -n device-1 deployments/helm/device-simulator > helm install -n device-2 deployments/helm/device-simulator > helm install -n device-3 deployments/helm/device-simulator Then pass a comma-separated list of device services to configure the onos-config pods to connect to each of the devices: > kubectl get svc NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE device-1-device-simulator ClusterIP 10.106.28.52 <none> 10161/TCP 49s device-2-device-simulator ClusterIP 10.98.157.220 <none> 10161/TCP 23s device-3-device-simulator ClusterIP 10.110.71.250 <none> 10161/TCP 17s > helm install \\ -n onos-config \\ --set ingress.enabled=true \\ --set devices='{device-1-device-simulator,device-2-device-simulator,device-3-device-simulator}' \\ deployments/helm/onos-config","title":"Deploying multiple simulators"},{"location":"onos-config/docs/dev_workflow/","text":"Developer Workflow Steps outlined in this page assume that the development prerequisites are met. Create Workspace Before making your first contribution, you should follow the steps to create your own GitHub fork and local workspace as outlined in the contributor guide . After this, you can browse the code and start making changes as necessary. Build and Test After you made some changes to the code locally, before opening a pull request you should run a few steps to make sure the code will pass validation by the CI: Run and pass make build Run and pass make test You can find more information on the full build process in the building onos-config document. Submit a Pull Request If the build and the test passed, you can commit your code and open a new pull request as described in more detail in the contributing to onos-config document. Pull Request Review process The pull request you just opened will be checked by our Travis CI system and reviewed by the community. Once it is approved, it will be merged it with a squash and merge strategy. If you are requested for changes in your pull request please go back and start again with step number 4 in the contributing to onos-config guide .","title":"Developer Workflow"},{"location":"onos-config/docs/dev_workflow/#developer-workflow","text":"Steps outlined in this page assume that the development prerequisites are met.","title":"Developer Workflow"},{"location":"onos-config/docs/dev_workflow/#create-workspace","text":"Before making your first contribution, you should follow the steps to create your own GitHub fork and local workspace as outlined in the contributor guide . After this, you can browse the code and start making changes as necessary.","title":"Create Workspace"},{"location":"onos-config/docs/dev_workflow/#build-and-test","text":"After you made some changes to the code locally, before opening a pull request you should run a few steps to make sure the code will pass validation by the CI: Run and pass make build Run and pass make test You can find more information on the full build process in the building onos-config document.","title":"Build and Test"},{"location":"onos-config/docs/dev_workflow/#submit-a-pull-request","text":"If the build and the test passed, you can commit your code and open a new pull request as described in more detail in the contributing to onos-config document.","title":"Submit a Pull Request"},{"location":"onos-config/docs/dev_workflow/#pull-request-review-process","text":"The pull request you just opened will be checked by our Travis CI system and reviewed by the community. Once it is approved, it will be merged it with a squash and merge strategy. If you are requested for changes in your pull request please go back and start again with step number 4 in the contributing to onos-config guide .","title":"Pull Request Review process"},{"location":"onos-config/docs/gnmi/","text":"Northbound gNMI service The system provides a Northbound gNMI service. gNMI extensions supported on the Northbound are described in gnmi_extensions.md gnmi_cli utility A simple way to issue a gNMI requests is to use the gnmi_cli utility from the OpenConfig project. gnmi_cli utility through 'onit' On a deployed cluster the onos-cli pod has a gNMI client that can be used to format and send gNMI messages. To access the CLI use onit onos-cli to get in to the onos-cli pod and then run gnmi_cli from there. Accessing from local machine An alternative is to install on your system, install as follows: go get -u github.com/openconfig/gnmi/cmd/gnmi_cli For troubleshooting information see gnmi_user_manual.md Namespaces onos-config follows the YGOT project in simplification by not using namespaces in paths. This can be achieved because the YANG models used do not have clashing device names that need to be qualified by namespaces. This helps developers, avoiding un-needed complication and redundancy. Northbound gNMI Get Request onos-config extends standard gNMI as a method of accessing a complete configuration system consisting of several devices - each identified by target . It supports network wide configuration actions (multiple updates on multiple devices at once, and rollback of same). The gNMI Northbound interface is available through https on port 5150. A simple Get operation Use gnmi_cli -get to get configuration for a particular device (target) from the system. Use \"target\" as the identifier of the device, and the \"elem\" collection is the path to the requested element. If config from several devices are required, several paths can be added gnmi_cli -get -address onos-config:5150 \\ -proto \"path: <target: 'localhost-1', elem: <name: 'system'> elem: <name: 'clock' > elem: <name: 'config'> elem: <name: 'timezone-name'>>\" \\ -timeout 5s -alsologtostderr \\ -client_crt /etc/ssl/certs/client1.crt \\ -client_key /etc/ssl/certs/client1.key \\ -ca_crt /etc/ssl/certs/onfca.crt List all device names (targets) A useful way to retrieve all stored device names is with the command: gnmi_cli -get -address onos-config:5150 \\ -proto \"path: <target: '*'>\" \\ -timeout 5s -alsologtostderr \\ -client_crt /etc/ssl/certs/client1.crt \\ -client_key /etc/ssl/certs/client1.key \\ -ca_crt /etc/ssl/certs/onfca.crt The value in the response can be an individual value or a tree of values depending on the scope of the request. List complete configuration for a device (target) Use the following value for proto to get all configuration and operational state on a particular device -proto \"path: \" Get a keyed index in a list Use a proto value like: -proto \"path: elem: elem: elem: > elem: elem: > elem: elem: >\" Use wildcards in a path onos-config supports the wildcards * and ... in gNMI paths, meaning match one item of match all items respectively as defined in the gNMI specification . For instance to retrieve all instances of an interface use * as the key: gnmi_cli -get -address onos-config:5150 \\ -proto \"path:<target: 'localhost-1', elem:<name:'interfaces' > elem:<name:'interface' key:<key:'name' value:'*' > > elem:<name:'config'> elem:<name:'enabled' >>\" \\ -timeout 5s -alsologtostderr \\ -client_crt /etc/ssl/certs/client1.crt \\ -client_key /etc/ssl/certs/client1.key \\ -ca_crt /etc/ssl/certs/onfca.crt This returns the enabled config attribute of both interfaces 'eth1' and 'admin' To retrieve both the config and state values of both then additionally the use * in place of config : gnmi_cli -get -address onos-config:5150 \\ -proto \"path:<target: 'localhost-1', elem:<name:'interfaces' > elem:<name:'interface' key:<key:'name' value:'*' > > elem:<name:'*'> elem:<name:'enabled' >>\" \\ -timeout 5s -alsologtostderr \\ -client_crt /etc/ssl/certs/client1.crt \\ -client_key /etc/ssl/certs/client1.key \\ -ca_crt /etc/ssl/certs/onfca.crt If the device is connected and the OperationState cache is populated this returns 4 values - eth1 config and state enabled values and admin config and state enabled values. Device read only state get To retrieve state, non-configurable values, there is no difference with a normal gNMI get request. An example follows: gnmi_cli -get -address onos-config:5150 \\ -proto \"path: <target: 'localhost-1',elem:<name:'system' > elem:<name:'openflow' > elem:<name:'controllers' > elem:<name:'controller' key:<key:'name' value:'main' > > elem:<name:'connections' > elem:<name:'connection' key:<key:'aux-id' value:'0' > > elem:<name:'state' > elem:<name:'address'>>\" \\ -timeout 5s -alsologtostderr \\ -client_crt /etc/ssl/certs/client1.crt \\ -client_key /etc/ssl/certs/client1.key \\ -ca_crt /etc/ssl/certs/onfca.crt Northbound Set Request via gNMI Similarly, to make a gNMI Set request, use the gnmi_cli -set command as in the example below: gnmi_cli -address onos-config:5150 -set \\ -proto \"update: <path: <target: 'localhost-1', elem: <name: 'system'> elem: <name: 'clock' > elem: <name: 'config'> elem: <name: 'timezone-name'>> val: <string_val: 'Europe/Paris'>>\" \\ -timeout 5s -alsologtostderr \\ -client_crt /etc/ssl/certs/client1.crt \\ -client_key /etc/ssl/certs/client1.key \\ -ca_crt /etc/ssl/certs/onfca.crt giving a response like response: < path: < elem: < name: \"system\" > elem: < name: \"clock\" > elem: < name: \"config\" > elem: < name: \"timezone-name\" > target: \"localhost-1\" > op: UPDATE > timestamp: 1559122191 extension: < registered_ext: < id: 100 msg: \"happy_matsumoto\" > > The result will include a field as a gNMI SetResponse extension 100 giving randomly generated Network Change identifier, which may be subsequently used to rollback the change. If a specific name is desired for a Network Change, the set may be given in the SetRequest() with the 100 extension at the end of the -proto section like: \", extension: >\" See gnmi_extensions.md for more on gNMI extensions supported. The corresponding -get for this require using the -proto \"path: elem: elem: elem: >\" Currently (Jul '19) checking of the contents done only when a Model Plugin is loaded for the device type. 2 checks are done 1) that a attempt is not being made to change a readonly attribute and 2) that valid data types and values are being used. The config is only forwarded down to the southbound layer only if the config is correct and the device is registered in the topocache (currently in the deviceStore) If the target device is not currently known to onos-config the system will store the configuration internally and apply it to the target device when/if it becomes available. When the target becomes available onos-config will compute the latest configuration for it based on the set of applied changes and push it to the target with a standard set operation. Northbound Delete Request via gNMI A delete request in gNMI is done using the set request with delete paths instead of update or replace . To make a gNMI Set request do delete a path, use the gnmi_cli -set command as in the example below: gnmi_cli -address onos-config:5150 -set \\ -proto \"delete: <target: 'localhost-1', elem: <name: 'system'> elem: <name: 'clock' > elem: <name: 'config'> elem: <name: 'timezone-name'>>\" \\ -timeout 5s -alsologtostderr \\ -client_crt /etc/ssl/certs/client1.crt \\ -client_key /etc/ssl/certs/client1.key \\ -ca_crt /etc/ssl/certs/onfca.crt Northbound Subscribe Request for Stream Notifications via gNMI Similarly, to make a gNMI Subscribe request for streaming, use the gnmi_cli command as in the example below, please note the 0 as subscription mode to indicate streaming: gnmi_cli -address onos-config:5150 \\ -proto \"subscribe:<mode: 0, prefix:<>, subscription:<path: <target: 'localhost-1', elem: <name: 'system'> elem: <name: 'clock' > elem: <name: 'config'> elem: <name: 'timezone-name'>>>>\" \\ -timeout 5s -alsologtostderr \\ -client_crt /etc/ssl/certs/client1.crt \\ -client_key /etc/ssl/certs/client1.key \\ -ca_crt /etc/ssl/certs/onfca.crt This command will block until there is a change at the requested value that gets propagated to the underlying stream. Also as per gnmi_cli behaviour the updates get printed twice. Northbound Subscribe Once Request via gNMI Similarly, to make a gNMI Subscribe Once request, use the gnmi_cli command as in the example below, please note the 1 as subscription mode to indicate to send the response once: gnmi_cli -address onos-config:5150 \\ -proto \"subscribe:<mode: 1, prefix:<>, subscription:<path: <target: 'localhost-1', elem: <name: 'system'> elem: <name: 'clock' > elem: <name: 'config'> elem: <name: 'timezone-name'>>>>\" \\ -timeout 5s -alsologtostderr \\ -client_crt /etc/ssl/certs/client1.crt \\ -client_key /etc/ssl/certs/client1.key \\ -ca_crt /etc/ssl/certs/onfca.crt This command will fail if no value is set at that specific path. This is due to limitations of the gnmi_cli. Northbound Subscribe Poll Request via gNMI Similarly, to make a gNMI Subscribe POLL request, use the gnmi_cli command as in the example below, please note the 2 as subscription mode to indicate to send the response in a polling way every polling_interval specified seconds: gnmi_cli -address onos-config:5150 \\ -proto \"subscribe:<mode: 2, prefix:<>, subscription:<sample_interval: 5, path: <target: 'localhost-1', elem: <name: 'system'> elem: <name: 'clock' > elem: <name: 'config'> elem: <name: 'timezone-name'>>>>\" \\ -timeout 5s \\ -polling_interval 5s \\ -client_crt /etc/ssl/certs/client1.crt \\ -client_key /etc/ssl/certs/client1.key \\ -ca_crt /etc/ssl/certs/onfca.crt This command will fail if no value is set at that specific path. This is due to limitations of the gnmi_cli.","title":"Northbound gNMI service"},{"location":"onos-config/docs/gnmi/#northbound-gnmi-service","text":"The system provides a Northbound gNMI service. gNMI extensions supported on the Northbound are described in gnmi_extensions.md","title":"Northbound gNMI service"},{"location":"onos-config/docs/gnmi/#gnmi_cli-utility","text":"A simple way to issue a gNMI requests is to use the gnmi_cli utility from the OpenConfig project.","title":"gnmi_cli utility"},{"location":"onos-config/docs/gnmi/#gnmi_cli-utility-through-onit","text":"On a deployed cluster the onos-cli pod has a gNMI client that can be used to format and send gNMI messages. To access the CLI use onit onos-cli to get in to the onos-cli pod and then run gnmi_cli from there.","title":"gnmi_cli utility through 'onit'"},{"location":"onos-config/docs/gnmi/#accessing-from-local-machine","text":"An alternative is to install on your system, install as follows: go get -u github.com/openconfig/gnmi/cmd/gnmi_cli For troubleshooting information see gnmi_user_manual.md","title":"Accessing from local machine"},{"location":"onos-config/docs/gnmi/#namespaces","text":"onos-config follows the YGOT project in simplification by not using namespaces in paths. This can be achieved because the YANG models used do not have clashing device names that need to be qualified by namespaces. This helps developers, avoiding un-needed complication and redundancy.","title":"Namespaces"},{"location":"onos-config/docs/gnmi/#northbound-gnmi-get-request","text":"onos-config extends standard gNMI as a method of accessing a complete configuration system consisting of several devices - each identified by target . It supports network wide configuration actions (multiple updates on multiple devices at once, and rollback of same). The gNMI Northbound interface is available through https on port 5150.","title":"Northbound gNMI Get Request"},{"location":"onos-config/docs/gnmi/#a-simple-get-operation","text":"Use gnmi_cli -get to get configuration for a particular device (target) from the system. Use \"target\" as the identifier of the device, and the \"elem\" collection is the path to the requested element. If config from several devices are required, several paths can be added gnmi_cli -get -address onos-config:5150 \\ -proto \"path: <target: 'localhost-1', elem: <name: 'system'> elem: <name: 'clock' > elem: <name: 'config'> elem: <name: 'timezone-name'>>\" \\ -timeout 5s -alsologtostderr \\ -client_crt /etc/ssl/certs/client1.crt \\ -client_key /etc/ssl/certs/client1.key \\ -ca_crt /etc/ssl/certs/onfca.crt","title":"A simple Get operation"},{"location":"onos-config/docs/gnmi/#list-all-device-names-targets","text":"A useful way to retrieve all stored device names is with the command: gnmi_cli -get -address onos-config:5150 \\ -proto \"path: <target: '*'>\" \\ -timeout 5s -alsologtostderr \\ -client_crt /etc/ssl/certs/client1.crt \\ -client_key /etc/ssl/certs/client1.key \\ -ca_crt /etc/ssl/certs/onfca.crt The value in the response can be an individual value or a tree of values depending on the scope of the request.","title":"List all device names (targets)"},{"location":"onos-config/docs/gnmi/#list-complete-configuration-for-a-device-target","text":"Use the following value for proto to get all configuration and operational state on a particular device -proto \"path: \"","title":"List complete configuration for a device (target)"},{"location":"onos-config/docs/gnmi/#get-a-keyed-index-in-a-list","text":"Use a proto value like: -proto \"path: elem: elem: elem: > elem: elem: > elem: elem: >\"","title":"Get a keyed index in a list"},{"location":"onos-config/docs/gnmi/#use-wildcards-in-a-path","text":"onos-config supports the wildcards * and ... in gNMI paths, meaning match one item of match all items respectively as defined in the gNMI specification . For instance to retrieve all instances of an interface use * as the key: gnmi_cli -get -address onos-config:5150 \\ -proto \"path:<target: 'localhost-1', elem:<name:'interfaces' > elem:<name:'interface' key:<key:'name' value:'*' > > elem:<name:'config'> elem:<name:'enabled' >>\" \\ -timeout 5s -alsologtostderr \\ -client_crt /etc/ssl/certs/client1.crt \\ -client_key /etc/ssl/certs/client1.key \\ -ca_crt /etc/ssl/certs/onfca.crt This returns the enabled config attribute of both interfaces 'eth1' and 'admin' To retrieve both the config and state values of both then additionally the use * in place of config : gnmi_cli -get -address onos-config:5150 \\ -proto \"path:<target: 'localhost-1', elem:<name:'interfaces' > elem:<name:'interface' key:<key:'name' value:'*' > > elem:<name:'*'> elem:<name:'enabled' >>\" \\ -timeout 5s -alsologtostderr \\ -client_crt /etc/ssl/certs/client1.crt \\ -client_key /etc/ssl/certs/client1.key \\ -ca_crt /etc/ssl/certs/onfca.crt If the device is connected and the OperationState cache is populated this returns 4 values - eth1 config and state enabled values and admin config and state enabled values.","title":"Use wildcards in a path"},{"location":"onos-config/docs/gnmi/#device-read-only-state-get","text":"To retrieve state, non-configurable values, there is no difference with a normal gNMI get request. An example follows: gnmi_cli -get -address onos-config:5150 \\ -proto \"path: <target: 'localhost-1',elem:<name:'system' > elem:<name:'openflow' > elem:<name:'controllers' > elem:<name:'controller' key:<key:'name' value:'main' > > elem:<name:'connections' > elem:<name:'connection' key:<key:'aux-id' value:'0' > > elem:<name:'state' > elem:<name:'address'>>\" \\ -timeout 5s -alsologtostderr \\ -client_crt /etc/ssl/certs/client1.crt \\ -client_key /etc/ssl/certs/client1.key \\ -ca_crt /etc/ssl/certs/onfca.crt","title":"Device read only state get"},{"location":"onos-config/docs/gnmi/#northbound-set-request-via-gnmi","text":"Similarly, to make a gNMI Set request, use the gnmi_cli -set command as in the example below: gnmi_cli -address onos-config:5150 -set \\ -proto \"update: <path: <target: 'localhost-1', elem: <name: 'system'> elem: <name: 'clock' > elem: <name: 'config'> elem: <name: 'timezone-name'>> val: <string_val: 'Europe/Paris'>>\" \\ -timeout 5s -alsologtostderr \\ -client_crt /etc/ssl/certs/client1.crt \\ -client_key /etc/ssl/certs/client1.key \\ -ca_crt /etc/ssl/certs/onfca.crt giving a response like response: < path: < elem: < name: \"system\" > elem: < name: \"clock\" > elem: < name: \"config\" > elem: < name: \"timezone-name\" > target: \"localhost-1\" > op: UPDATE > timestamp: 1559122191 extension: < registered_ext: < id: 100 msg: \"happy_matsumoto\" > > The result will include a field as a gNMI SetResponse extension 100 giving randomly generated Network Change identifier, which may be subsequently used to rollback the change. If a specific name is desired for a Network Change, the set may be given in the SetRequest() with the 100 extension at the end of the -proto section like: \", extension: >\" See gnmi_extensions.md for more on gNMI extensions supported. The corresponding -get for this require using the -proto \"path: elem: elem: elem: >\" Currently (Jul '19) checking of the contents done only when a Model Plugin is loaded for the device type. 2 checks are done 1) that a attempt is not being made to change a readonly attribute and 2) that valid data types and values are being used. The config is only forwarded down to the southbound layer only if the config is correct and the device is registered in the topocache (currently in the deviceStore) If the target device is not currently known to onos-config the system will store the configuration internally and apply it to the target device when/if it becomes available. When the target becomes available onos-config will compute the latest configuration for it based on the set of applied changes and push it to the target with a standard set operation.","title":"Northbound Set Request via gNMI"},{"location":"onos-config/docs/gnmi/#northbound-delete-request-via-gnmi","text":"A delete request in gNMI is done using the set request with delete paths instead of update or replace . To make a gNMI Set request do delete a path, use the gnmi_cli -set command as in the example below: gnmi_cli -address onos-config:5150 -set \\ -proto \"delete: <target: 'localhost-1', elem: <name: 'system'> elem: <name: 'clock' > elem: <name: 'config'> elem: <name: 'timezone-name'>>\" \\ -timeout 5s -alsologtostderr \\ -client_crt /etc/ssl/certs/client1.crt \\ -client_key /etc/ssl/certs/client1.key \\ -ca_crt /etc/ssl/certs/onfca.crt","title":"Northbound Delete Request via gNMI"},{"location":"onos-config/docs/gnmi/#northbound-subscribe-request-for-stream-notifications-via-gnmi","text":"Similarly, to make a gNMI Subscribe request for streaming, use the gnmi_cli command as in the example below, please note the 0 as subscription mode to indicate streaming: gnmi_cli -address onos-config:5150 \\ -proto \"subscribe:<mode: 0, prefix:<>, subscription:<path: <target: 'localhost-1', elem: <name: 'system'> elem: <name: 'clock' > elem: <name: 'config'> elem: <name: 'timezone-name'>>>>\" \\ -timeout 5s -alsologtostderr \\ -client_crt /etc/ssl/certs/client1.crt \\ -client_key /etc/ssl/certs/client1.key \\ -ca_crt /etc/ssl/certs/onfca.crt This command will block until there is a change at the requested value that gets propagated to the underlying stream. Also as per gnmi_cli behaviour the updates get printed twice.","title":"Northbound Subscribe Request for Stream Notifications via gNMI"},{"location":"onos-config/docs/gnmi/#northbound-subscribe-once-request-via-gnmi","text":"Similarly, to make a gNMI Subscribe Once request, use the gnmi_cli command as in the example below, please note the 1 as subscription mode to indicate to send the response once: gnmi_cli -address onos-config:5150 \\ -proto \"subscribe:<mode: 1, prefix:<>, subscription:<path: <target: 'localhost-1', elem: <name: 'system'> elem: <name: 'clock' > elem: <name: 'config'> elem: <name: 'timezone-name'>>>>\" \\ -timeout 5s -alsologtostderr \\ -client_crt /etc/ssl/certs/client1.crt \\ -client_key /etc/ssl/certs/client1.key \\ -ca_crt /etc/ssl/certs/onfca.crt This command will fail if no value is set at that specific path. This is due to limitations of the gnmi_cli.","title":"Northbound Subscribe Once Request via gNMI"},{"location":"onos-config/docs/gnmi/#northbound-subscribe-poll-request-via-gnmi","text":"Similarly, to make a gNMI Subscribe POLL request, use the gnmi_cli command as in the example below, please note the 2 as subscription mode to indicate to send the response in a polling way every polling_interval specified seconds: gnmi_cli -address onos-config:5150 \\ -proto \"subscribe:<mode: 2, prefix:<>, subscription:<sample_interval: 5, path: <target: 'localhost-1', elem: <name: 'system'> elem: <name: 'clock' > elem: <name: 'config'> elem: <name: 'timezone-name'>>>>\" \\ -timeout 5s \\ -polling_interval 5s \\ -client_crt /etc/ssl/certs/client1.crt \\ -client_key /etc/ssl/certs/client1.key \\ -ca_crt /etc/ssl/certs/onfca.crt This command will fail if no value is set at that specific path. This is due to limitations of the gnmi_cli.","title":"Northbound Subscribe Poll Request via gNMI"},{"location":"onos-config/docs/gnmi_extensions/","text":"gNMI extensions on the Northbound interface gNMI is designed primarily as a device management interface, and augmenting it with the extra functionality to do network wide configuration management across many devices requires some extension. Some functions (e.g. rollback and version management) are far beyond what gNMI is designed for, and have been given their own gRPC definitons as admin and diags . Use of target in the NBI In gNMI the Path type is comprised of a set of path elements and a target . In the onos-config NBI this target represents the name of the device as it is held in the configuration system. Configurations can be explored through the onos cli like: > onos config get configs Device2-2.0.0 (Device2) 2.0.0 TestDevice 2019-05-09T18:00:00+01:00 oOqIgEg82ZvVcF7Q3xEDpWAoPcw= stratum-sim-1-1.0.0 (stratum-sim-1) 1.0.0 Stratum 2019-06-05T11:03:17+01:00 hPE88W6rrt5TskCTxtoB1n0hr3I= ... In the example above stratum-sim-1 is the device associated with the configuration stratum-sim-1-1.0.0 . Therefore when using a gNMI client like gnmi_cli (see gnmi.md ) the target can be specified like gnmi_cli -get -address localhost:5150 \\ -proto \"path: <target: 'stratum-sim-1', elem: <name: 'system'> elem:<name:'config'> elem: <name: 'motd-banner'>>\" \\ ... The following rules apply when a prefix is present in the request: * The target in the prefix always takes precedence over any others * If no target is given in the prefix it is an error Special case to get all device names When doing a GetRequest if '*' is given as a target then the request returns a simple listing of all device names present in the system (with their version). Any path elements are ignored in this special case. Managing configuration objects The diagram shows the internal storage structures of onos-config (in orange). The Configuration object represents the complete configuration for a particular version of a device. Network changes can be applied across multiple Configurations (devices), and have the ability to be rolled back (by the name of the Network Change). 3 different extensions have been chosen in the project to make dealing with Network Changes and Configurations through gNMI possible. Use of Extension 100 (network change name) in SetRequest and SetResponse In onos-config the gNMI extension number 100 has been reserved for the network change name . SetRequest In the SetRequest extension 100 can be used to define a name for the Network change. If it is not specified then a name is picked automatically. There is an example of setting this extension when using gnmi_cli in gnmi.md (Northbound Set Request via gNMI) SetResponse In the SetResponse the name of the Network Change will always be given in extension 100 (either the given name or the generated one). There is an example of the return of this extension through gnmi_cli in gnmi.md (Northbound Set Request via gNMI) Use of Extension 101 (device version) in SetRequest Extension 101 is used to set the Model version for a Configuration (as part of a Network Change). There may be multiple different configurations for a device based on version number. This extension allows the correct version of the configuration to be chosen. If a version is given where no existing Configuration exists, an error is returned explaining that device type (extension 102 - see below) should also be specified. If no extension 101 (version) is given, and only one Configuration already exists for that device (target), then the change is applied to that Configuration. Use of Extension 102 (device type) in SetRequest The target in the SetRequest contains the device name, but this is not enough to create a new Configuration if one does not exist - 3 pieces of information are required - the device name, the device type and the version (see diagram above). Extension 102 is used to set the device type . If a Configuration already exists for this device name and version and its device type is different to what's given in extension 101, then an error is returned.","title":"gNMI extensions on the Northbound interface"},{"location":"onos-config/docs/gnmi_extensions/#gnmi-extensions-on-the-northbound-interface","text":"gNMI is designed primarily as a device management interface, and augmenting it with the extra functionality to do network wide configuration management across many devices requires some extension. Some functions (e.g. rollback and version management) are far beyond what gNMI is designed for, and have been given their own gRPC definitons as admin and diags .","title":"gNMI extensions on the Northbound interface"},{"location":"onos-config/docs/gnmi_extensions/#use-of-target-in-the-nbi","text":"In gNMI the Path type is comprised of a set of path elements and a target . In the onos-config NBI this target represents the name of the device as it is held in the configuration system. Configurations can be explored through the onos cli like: > onos config get configs Device2-2.0.0 (Device2) 2.0.0 TestDevice 2019-05-09T18:00:00+01:00 oOqIgEg82ZvVcF7Q3xEDpWAoPcw= stratum-sim-1-1.0.0 (stratum-sim-1) 1.0.0 Stratum 2019-06-05T11:03:17+01:00 hPE88W6rrt5TskCTxtoB1n0hr3I= ... In the example above stratum-sim-1 is the device associated with the configuration stratum-sim-1-1.0.0 . Therefore when using a gNMI client like gnmi_cli (see gnmi.md ) the target can be specified like gnmi_cli -get -address localhost:5150 \\ -proto \"path: <target: 'stratum-sim-1', elem: <name: 'system'> elem:<name:'config'> elem: <name: 'motd-banner'>>\" \\ ... The following rules apply when a prefix is present in the request: * The target in the prefix always takes precedence over any others * If no target is given in the prefix it is an error","title":"Use of target in the NBI"},{"location":"onos-config/docs/gnmi_extensions/#special-case-to-get-all-device-names","text":"When doing a GetRequest if '*' is given as a target then the request returns a simple listing of all device names present in the system (with their version). Any path elements are ignored in this special case.","title":"Special case to get all device names"},{"location":"onos-config/docs/gnmi_extensions/#managing-configuration-objects","text":"The diagram shows the internal storage structures of onos-config (in orange). The Configuration object represents the complete configuration for a particular version of a device. Network changes can be applied across multiple Configurations (devices), and have the ability to be rolled back (by the name of the Network Change). 3 different extensions have been chosen in the project to make dealing with Network Changes and Configurations through gNMI possible.","title":"Managing configuration objects"},{"location":"onos-config/docs/gnmi_extensions/#use-of-extension-100-network-change-name-in-setrequest-and-setresponse","text":"In onos-config the gNMI extension number 100 has been reserved for the network change name .","title":"Use of Extension 100 (network change name) in SetRequest and SetResponse"},{"location":"onos-config/docs/gnmi_extensions/#setrequest","text":"In the SetRequest extension 100 can be used to define a name for the Network change. If it is not specified then a name is picked automatically. There is an example of setting this extension when using gnmi_cli in gnmi.md (Northbound Set Request via gNMI)","title":"SetRequest"},{"location":"onos-config/docs/gnmi_extensions/#setresponse","text":"In the SetResponse the name of the Network Change will always be given in extension 100 (either the given name or the generated one). There is an example of the return of this extension through gnmi_cli in gnmi.md (Northbound Set Request via gNMI)","title":"SetResponse"},{"location":"onos-config/docs/gnmi_extensions/#use-of-extension-101-device-version-in-setrequest","text":"Extension 101 is used to set the Model version for a Configuration (as part of a Network Change). There may be multiple different configurations for a device based on version number. This extension allows the correct version of the configuration to be chosen. If a version is given where no existing Configuration exists, an error is returned explaining that device type (extension 102 - see below) should also be specified. If no extension 101 (version) is given, and only one Configuration already exists for that device (target), then the change is applied to that Configuration.","title":"Use of Extension 101 (device version) in SetRequest"},{"location":"onos-config/docs/gnmi_extensions/#use-of-extension-102-device-type-in-setrequest","text":"The target in the SetRequest contains the device name, but this is not enough to create a new Configuration if one does not exist - 3 pieces of information are required - the device name, the device type and the version (see diagram above). Extension 102 is used to set the device type . If a Configuration already exists for this device name and version and its device type is different to what's given in extension 101, then an error is returned.","title":"Use of Extension 102 (device type) in SetRequest"},{"location":"onos-config/docs/license_goland/","text":"GoLand Copyright Profile Setup GoLand IDE can be configured to automatically include the required Apache 2.0 license text in Go source files. Steps to do this are shown below: Open Preferences window Select Editor->Copyright->Copyright Profiles Click the plus icon Name the new profie onos Cut and paste the text from here into the copyright field Click Apply Open Formatting then Go Click check box for Use Custom Formatting Options Click checkbox Use Line Comment Click Apply Once the new copyright profile is created, it needs to be applied to the project: * Select Editor->Copyright * Choose onos in the Default Project Copyright drop-down list * Click OK","title":"GoLand Copyright Profile Setup"},{"location":"onos-config/docs/license_goland/#goland-copyright-profile-setup","text":"GoLand IDE can be configured to automatically include the required Apache 2.0 license text in Go source files. Steps to do this are shown below: Open Preferences window Select Editor->Copyright->Copyright Profiles Click the plus icon Name the new profie onos Cut and paste the text from here into the copyright field Click Apply Open Formatting then Go Click check box for Use Custom Formatting Options Click checkbox Use Line Comment Click Apply Once the new copyright profile is created, it needs to be applied to the project: * Select Editor->Copyright * Choose onos in the Default Project Copyright drop-down list * Click OK","title":"GoLand Copyright Profile Setup"},{"location":"onos-config/docs/modelplugin/","text":"Extending onos-config with Model Plugins onos-config is an extensible configuration management system, that allows the configuration of many different types and versions of devices to be managed concurrently. Information models in YANG format (RFC 6020) can be used to accurately define the configuration and state objects and attributes of a device. In practice a device's object model usually comprises of a number of YANG files including augments and deviations, and must be considered as a combined unit. In onos-config a set of these combined YANG files defining a particular version of a device type is known as a model . Over its lifecycle onos-config will have to deal with many different models as its scope is expanded and as devices go through new release cycles. To allow this models are loadable dynamically as plugins in the form of Linux or Mac shared object libraries (*.so) using the YGOT library and are know as Model Plugins . The diagram shows the connection between the Model Plugin and the configuration store - linked by Device Type and Version. Effectively the primary key of the Model Registry is the Model Name and Version, whereas the primary key of the Configuration is the Device Name and Version. Role of the Model Plugin The Model Plugin enables the following functionality in onos-config : 1) Ensures that illegal values are not saved in to the configuration (this covers wrong data type, data values beyond range or not matching a pattern, lists that are not within their cardinality limits) 1) Ensuring that read only values are not allowed to be set 1) Checking the validity of stores on startup 1) Enabling the Operational State cache within onos-config 1) Enabling the retrieval of attributes by type - CONFIG or OPERATIONAL 1) Enabling clients to access the model metadata through the Admin NBI 1) Enabling JSON Payloads in gNMI SetRequests to be interpreted Structure of a Model Plugin A Model Plugin is mainly generated by the generator command from the YGOT project, and a wrapper modelmain.go implementing the ModelPlugin interface. They are compiled together with the go build command using the -buildmode=plugin option. Many examples of Model Plugins are in the modelplugin folder of this project, and an example script ModelGenerator.sh is available for creating new plugins. ModelPlugin Interface The model plugin must implement the ModelPlugin interface. This will allow it to be entered in to the Model Registry. type ModelPlugin interface { ModelData() (string, string, []*gnmi.ModelData, string) UnmarshalConfigValues(jsonTree []byte) (*ygot.ValidatedGoStruct, error) Validate(*ygot.ValidatedGoStruct, ...ygot.ValidationOption) error Schema() (map[string]*yang.Entry, error) } Create your own Model Plugin using script 1) Change directory in to onos-config/modelplugins 1) Copy ModelGenerator.sh to a new file 1) Edit the variables at the top of the file to suit your plugin (see modelmain.go Definitions below for specifics), taking special care that the entries in MODELDATA and YANGLIST match each other and are in alphabetical order 1) Make sure the required Yang files are present in the ./yang folder and named properly 1) Run the script like > ./ModelGenerator.sh Once the files are created: 1) Change directory back to onos-config 2) Compile the plugin with (replacing the names as appropriate) > GO111MODULE=on CGO_ENABLED=1 go build -o modelplugin/TestDevice-1.0.0/testdevice.so.1.0.0 -buildmode=plugin -tags=modelplugin ./modelplugin/TestDevice-1.0.0 Follow the steps in Loading the Model Plugin below for how to load it. YANG files The YANG files to be used with generator.go should be collected together in a folder and named in the style: \\ @\\ .yang Note The Yang files provided are required not to contain overlapping or clashing namespaces at the same path level. This requirement is necessary during the model compilation in YGOT because this tool offers no support for namespaces in the form of /namespace:path/path2 , e.g. /openconfig-system:system/clock . YGOT compilation of a model containing /openconfig-system:system/clock will result in the path being /system/clock Running the generator command in the form: > go run $GOPATH/src/github.com/openconfig/ygot/generator/generator.go \\ -path yang -output_file=$TYPEVERSION/$TYPEVERSIONPKG/generated.go -package_name=$TYPEVERSIONPKG \\ -generate_fakeroot $YANGLIST will check all nested dependencies are present, and that the output is generated as a single file: generated.go . Where $YANGLIST is a space separated list of YANG file names. See ModelGenerator.sh for an example To visualize and further validate the collection of YANG files, the pyang tool can be used like: > pyang -f tree $YANGLIST Once the generator has run there is no need to persist the YANG files - the generated.go file contains all the information in an object model. modelmain.go definitions Examples of these definitions are given in ModelGenerator.sh modeltype This should be a name that defines the type of device, but should not include version. This name will be used later in the Configuration of the device. It should be between 4 and 40 chars and only include alphanumeric characters, dash, underscore and colon. modelversion This should be the version number of the device in Semantic Versioning form. Only numeric characters and '.' character are allowed. modulename This should be the same as the filename given to the Model Plugin when compiled. It comprises * the modeltype (converted to lower case), * concatenated with '.so.' and * the version. e.g. devicesim.so.1.0.0 modeldata The primary YANG files of the device should be listed in the ModelData section of the modelmain.go file. These are the YANG files that define the top level containers and lists. During compilation other YANG files may get pulled in because they define reusable types (but should not be listed in model data). Each entry in modeldata should be in the format of * name - the name of the module inside the YANG file * version - the value of the latest revision inside the YANG file in the format YYYY-MM-DD * organization - the value from the organization field of the YANG file There should be no duplicate entries (of name) in the list and the list should be ordered alphabetically. Loading the Model Plugin The Model Plugin can be loaded at the start up of onos-config by specifying the -modelPlugin argument. bash -modelPlugin=$HOME/go/src/github.com/onosproject/onos-config/modelplugin/TestDevice-1.0.0/testdevice.so.1.0.0 \\ -modelPlugin=$HOME/go/src/github.com/onosproject/onos-config/modelplugin/TestDevice-2.0.0/testdevice.so.2.0.0 \\ -modelPlugin=$HOME/go/src/github.com/onosproject/onos-config/modelplugin/Devicesim-1.0.0/devicesim.so.1.0.0 \\ -modelPlugin=$HOME/go/src/github.com/onosproject/onos-config/modelplugin/Stratum-1.0.0/stratum.so.1.0.0 Alternatively these can loaded later with the onos cli tool - see cli.md . ```bash onos config add plugin ``` Model Plugins cannot be unloaded once loaded, without restarting onos-config. To see a list of loaded plugins use the command: > onos config get plugins which gives an output like: > onos config get plugins TestDevice: 1.0.0 from testdevice.so.1.0.0 containing: YANGS: test1 2018-02-20 Open Networking Foundation TestDevice: 2.0.0 from testdevice.so.2.0.0 containing: YANGS: test1 2019-06-10 Open Networking Foundation Devicesim: 1.0.0 from devicesim.so.1.0.0 containing: YANGS: openconfig-interfaces 2017-07-14 OpenConfig working group openconfig-openflow 2017-06-01 OpenConfig working group openconfig-platform 2016-12-22 OpenConfig working group openconfig-system 2017-07-06 OpenConfig working group Stratum: 1.0.0 from stratum.so.1.0.0 containing: YANGS: openconfig-interfaces 2.4.1 OpenConfig working group openconfig-if-ip 3.0.0 OpenConfig working group openconfig-lacp 1.1.1 OpenConfig working group openconfig-platform 0.12.2 OpenConfig working group openconfig-platform-linecard 0.1.1 OpenConfig working group openconfig-platform-port 0.3.2 OpenConfig working group openconfig-platform-transceiver 0.7.0 OpenConfig working group openconfig-vlan 3.2.0 OpenConfig working group openconfig-system 0.7.0 OpenConfig working group openconfig-hercules-platform-linecard 0.2.0 OpenConfig working group openconfig-hercules-qos 0.1.0 OpenConfig working group openconfig-hercules-platform 0.2.0 OpenConfig working group openconfig-hercules-platform-chassis 0.2.0 OpenConfig working group openconfig-hercules-platform-port 0.2.0 OpenConfig working group openconfig-hercules 0.2.0 OpenConfig working group openconfig-hercules-interfaces 0.2.0 OpenConfig working group openconfig-hercules-platform-node 0.2.0 OpenConfig working group To see a list of Read-Only and Read-Write paths use the command: > onos config get plugins -v In a distributed installation the ModelPlugin will have to be loaded on all running instances of onos-config. Model Plugins and gNMI Capabilities Capabilities on gNMI Northbound interface The CapabilitiesResponse on the gNMI northound interface is generated dynamically from the modeldata section of all of the loaded Model Plugins. Capabilities comparison on Southbound gNMI interface At runtime when devices are connected to onos-config the response to the Capabilities request are compared with the modeldata for their corresponding ModelPlugin - if there is not an exact match a warning is displayed. OpenConfig Models Some devices that support OpenConfig Models report their capabilities using an OpenConfig versioning scheme e.g. 0.5.0, rather than the YANG revision date in the format 2017-07-06. If the device can correct its capabilities to give the revision then it should to be more consistent with non OpenConfig YANG models. Accessing OpenConfig model of a specific revision requires a number of steps in Github . For instance if a device reports it used openconfig-interfacess.yang 2.0.0 , then to get this file do: * Browse to openconfig-interfaces.yang * Observe in the list of revision items in the YANG file that the reference 2.0.0 corresponds to a release date of 2017-07-14 * Click in the History button * In the History page for this file, see that the next commit after this date was on Aug 9, 2017 * Click on the related commit message * In the list of files modified in that commit click the ... next to the file openconfig-interfacess.yang and choose View File * In the page that displays the historical version of the file, click the Raw button * In the resulting raw display of the YANG file verify that the latest revision is 2017-07-14 * Save the file locally as openconfig-interfaces@2017-07-14.yang All the files in the yang folder were downloaded in this way. They are not strictly needed once generated.go has been created, but are kept here for convenience, saving to have to run the procedure above if a change was needed. If the generator program reports that a dependency was required e.g. openconfig-inet-types.yang then the version of this file with a date equal to or before 2017-07-14 should be downloaded - it is openconfig-inet-types@2017-07-14.yang Readonly paths in OpenConfig models When an item in an Openconfig YANG file has \"config false\" it is effectively a read-only attribute. Usually with OpenConfig read-only objects are interspersed throughout the YANG model. To see a list of Read Only paths use the command: > onos config get plugins -v When the Model Plugin is loaded, setting of an attribute like state/address should give an appropriate error > gnmi_cli -address localhost:5150 -set \\ -proto \"update: <path: <target: 'localhost-1', elem: <name: 'system'> elem: <name: 'openflow'> elem: <name: 'controllers'> elem: <name: 'controller' key: <key: 'name' value: 'main'>> elem: <name: 'connections'> elem: <name: 'connection' key: <key: 'aux-id' value: '0'>> elem: <name: 'state'> elem: <name: 'address'>> val: <string_val: '192.0.2.11'>>\" \\ -timeout 5s -alsologtostderr \\ -client_crt pkg/southbound/testdata/client1.crt \\ -client_key pkg/southbound/testdata/client1.key \\ -ca_crt pkg/southbound/testdata/onfca.crt gives the error: rpc error: code = InvalidArgument desc = update contains a change to a read only path /system/openflow/controllers/controller[name=main]/connections/connection[aux-id=0]/state/address. Rejected","title":"Extending onos-config with Model Plugins"},{"location":"onos-config/docs/modelplugin/#extending-onos-config-with-model-plugins","text":"onos-config is an extensible configuration management system, that allows the configuration of many different types and versions of devices to be managed concurrently. Information models in YANG format (RFC 6020) can be used to accurately define the configuration and state objects and attributes of a device. In practice a device's object model usually comprises of a number of YANG files including augments and deviations, and must be considered as a combined unit. In onos-config a set of these combined YANG files defining a particular version of a device type is known as a model . Over its lifecycle onos-config will have to deal with many different models as its scope is expanded and as devices go through new release cycles. To allow this models are loadable dynamically as plugins in the form of Linux or Mac shared object libraries (*.so) using the YGOT library and are know as Model Plugins . The diagram shows the connection between the Model Plugin and the configuration store - linked by Device Type and Version. Effectively the primary key of the Model Registry is the Model Name and Version, whereas the primary key of the Configuration is the Device Name and Version.","title":"Extending onos-config with Model Plugins"},{"location":"onos-config/docs/modelplugin/#role-of-the-model-plugin","text":"The Model Plugin enables the following functionality in onos-config : 1) Ensures that illegal values are not saved in to the configuration (this covers wrong data type, data values beyond range or not matching a pattern, lists that are not within their cardinality limits) 1) Ensuring that read only values are not allowed to be set 1) Checking the validity of stores on startup 1) Enabling the Operational State cache within onos-config 1) Enabling the retrieval of attributes by type - CONFIG or OPERATIONAL 1) Enabling clients to access the model metadata through the Admin NBI 1) Enabling JSON Payloads in gNMI SetRequests to be interpreted","title":"Role of the Model Plugin"},{"location":"onos-config/docs/modelplugin/#structure-of-a-model-plugin","text":"A Model Plugin is mainly generated by the generator command from the YGOT project, and a wrapper modelmain.go implementing the ModelPlugin interface. They are compiled together with the go build command using the -buildmode=plugin option. Many examples of Model Plugins are in the modelplugin folder of this project, and an example script ModelGenerator.sh is available for creating new plugins.","title":"Structure of a Model Plugin"},{"location":"onos-config/docs/modelplugin/#modelplugin-interface","text":"The model plugin must implement the ModelPlugin interface. This will allow it to be entered in to the Model Registry. type ModelPlugin interface { ModelData() (string, string, []*gnmi.ModelData, string) UnmarshalConfigValues(jsonTree []byte) (*ygot.ValidatedGoStruct, error) Validate(*ygot.ValidatedGoStruct, ...ygot.ValidationOption) error Schema() (map[string]*yang.Entry, error) }","title":"ModelPlugin Interface"},{"location":"onos-config/docs/modelplugin/#create-your-own-model-plugin-using-script","text":"1) Change directory in to onos-config/modelplugins 1) Copy ModelGenerator.sh to a new file 1) Edit the variables at the top of the file to suit your plugin (see modelmain.go Definitions below for specifics), taking special care that the entries in MODELDATA and YANGLIST match each other and are in alphabetical order 1) Make sure the required Yang files are present in the ./yang folder and named properly 1) Run the script like > ./ModelGenerator.sh Once the files are created: 1) Change directory back to onos-config 2) Compile the plugin with (replacing the names as appropriate) > GO111MODULE=on CGO_ENABLED=1 go build -o modelplugin/TestDevice-1.0.0/testdevice.so.1.0.0 -buildmode=plugin -tags=modelplugin ./modelplugin/TestDevice-1.0.0 Follow the steps in Loading the Model Plugin below for how to load it.","title":"Create your own Model Plugin using script"},{"location":"onos-config/docs/modelplugin/#yang-files","text":"The YANG files to be used with generator.go should be collected together in a folder and named in the style: \\ @\\ .yang Note The Yang files provided are required not to contain overlapping or clashing namespaces at the same path level. This requirement is necessary during the model compilation in YGOT because this tool offers no support for namespaces in the form of /namespace:path/path2 , e.g. /openconfig-system:system/clock . YGOT compilation of a model containing /openconfig-system:system/clock will result in the path being /system/clock Running the generator command in the form: > go run $GOPATH/src/github.com/openconfig/ygot/generator/generator.go \\ -path yang -output_file=$TYPEVERSION/$TYPEVERSIONPKG/generated.go -package_name=$TYPEVERSIONPKG \\ -generate_fakeroot $YANGLIST will check all nested dependencies are present, and that the output is generated as a single file: generated.go . Where $YANGLIST is a space separated list of YANG file names. See ModelGenerator.sh for an example To visualize and further validate the collection of YANG files, the pyang tool can be used like: > pyang -f tree $YANGLIST Once the generator has run there is no need to persist the YANG files - the generated.go file contains all the information in an object model.","title":"YANG files"},{"location":"onos-config/docs/modelplugin/#modelmaingo-definitions","text":"Examples of these definitions are given in ModelGenerator.sh","title":"modelmain.go definitions"},{"location":"onos-config/docs/modelplugin/#modeltype","text":"This should be a name that defines the type of device, but should not include version. This name will be used later in the Configuration of the device. It should be between 4 and 40 chars and only include alphanumeric characters, dash, underscore and colon.","title":"modeltype"},{"location":"onos-config/docs/modelplugin/#modelversion","text":"This should be the version number of the device in Semantic Versioning form. Only numeric characters and '.' character are allowed.","title":"modelversion"},{"location":"onos-config/docs/modelplugin/#modulename","text":"This should be the same as the filename given to the Model Plugin when compiled. It comprises * the modeltype (converted to lower case), * concatenated with '.so.' and * the version. e.g. devicesim.so.1.0.0","title":"modulename"},{"location":"onos-config/docs/modelplugin/#modeldata","text":"The primary YANG files of the device should be listed in the ModelData section of the modelmain.go file. These are the YANG files that define the top level containers and lists. During compilation other YANG files may get pulled in because they define reusable types (but should not be listed in model data). Each entry in modeldata should be in the format of * name - the name of the module inside the YANG file * version - the value of the latest revision inside the YANG file in the format YYYY-MM-DD * organization - the value from the organization field of the YANG file There should be no duplicate entries (of name) in the list and the list should be ordered alphabetically.","title":"modeldata"},{"location":"onos-config/docs/modelplugin/#loading-the-model-plugin","text":"The Model Plugin can be loaded at the start up of onos-config by specifying the -modelPlugin argument. bash -modelPlugin=$HOME/go/src/github.com/onosproject/onos-config/modelplugin/TestDevice-1.0.0/testdevice.so.1.0.0 \\ -modelPlugin=$HOME/go/src/github.com/onosproject/onos-config/modelplugin/TestDevice-2.0.0/testdevice.so.2.0.0 \\ -modelPlugin=$HOME/go/src/github.com/onosproject/onos-config/modelplugin/Devicesim-1.0.0/devicesim.so.1.0.0 \\ -modelPlugin=$HOME/go/src/github.com/onosproject/onos-config/modelplugin/Stratum-1.0.0/stratum.so.1.0.0 Alternatively these can loaded later with the onos cli tool - see cli.md . ```bash onos config add plugin ``` Model Plugins cannot be unloaded once loaded, without restarting onos-config. To see a list of loaded plugins use the command: > onos config get plugins which gives an output like: > onos config get plugins TestDevice: 1.0.0 from testdevice.so.1.0.0 containing: YANGS: test1 2018-02-20 Open Networking Foundation TestDevice: 2.0.0 from testdevice.so.2.0.0 containing: YANGS: test1 2019-06-10 Open Networking Foundation Devicesim: 1.0.0 from devicesim.so.1.0.0 containing: YANGS: openconfig-interfaces 2017-07-14 OpenConfig working group openconfig-openflow 2017-06-01 OpenConfig working group openconfig-platform 2016-12-22 OpenConfig working group openconfig-system 2017-07-06 OpenConfig working group Stratum: 1.0.0 from stratum.so.1.0.0 containing: YANGS: openconfig-interfaces 2.4.1 OpenConfig working group openconfig-if-ip 3.0.0 OpenConfig working group openconfig-lacp 1.1.1 OpenConfig working group openconfig-platform 0.12.2 OpenConfig working group openconfig-platform-linecard 0.1.1 OpenConfig working group openconfig-platform-port 0.3.2 OpenConfig working group openconfig-platform-transceiver 0.7.0 OpenConfig working group openconfig-vlan 3.2.0 OpenConfig working group openconfig-system 0.7.0 OpenConfig working group openconfig-hercules-platform-linecard 0.2.0 OpenConfig working group openconfig-hercules-qos 0.1.0 OpenConfig working group openconfig-hercules-platform 0.2.0 OpenConfig working group openconfig-hercules-platform-chassis 0.2.0 OpenConfig working group openconfig-hercules-platform-port 0.2.0 OpenConfig working group openconfig-hercules 0.2.0 OpenConfig working group openconfig-hercules-interfaces 0.2.0 OpenConfig working group openconfig-hercules-platform-node 0.2.0 OpenConfig working group To see a list of Read-Only and Read-Write paths use the command: > onos config get plugins -v In a distributed installation the ModelPlugin will have to be loaded on all running instances of onos-config.","title":"Loading the Model Plugin"},{"location":"onos-config/docs/modelplugin/#model-plugins-and-gnmi-capabilities","text":"","title":"Model Plugins and gNMI Capabilities"},{"location":"onos-config/docs/modelplugin/#capabilities-on-gnmi-northbound-interface","text":"The CapabilitiesResponse on the gNMI northound interface is generated dynamically from the modeldata section of all of the loaded Model Plugins.","title":"Capabilities on gNMI Northbound interface"},{"location":"onos-config/docs/modelplugin/#capabilities-comparison-on-southbound-gnmi-interface","text":"At runtime when devices are connected to onos-config the response to the Capabilities request are compared with the modeldata for their corresponding ModelPlugin - if there is not an exact match a warning is displayed.","title":"Capabilities comparison on Southbound gNMI interface"},{"location":"onos-config/docs/modelplugin/#openconfig-models","text":"Some devices that support OpenConfig Models report their capabilities using an OpenConfig versioning scheme e.g. 0.5.0, rather than the YANG revision date in the format 2017-07-06. If the device can correct its capabilities to give the revision then it should to be more consistent with non OpenConfig YANG models. Accessing OpenConfig model of a specific revision requires a number of steps in Github . For instance if a device reports it used openconfig-interfacess.yang 2.0.0 , then to get this file do: * Browse to openconfig-interfaces.yang * Observe in the list of revision items in the YANG file that the reference 2.0.0 corresponds to a release date of 2017-07-14 * Click in the History button * In the History page for this file, see that the next commit after this date was on Aug 9, 2017 * Click on the related commit message * In the list of files modified in that commit click the ... next to the file openconfig-interfacess.yang and choose View File * In the page that displays the historical version of the file, click the Raw button * In the resulting raw display of the YANG file verify that the latest revision is 2017-07-14 * Save the file locally as openconfig-interfaces@2017-07-14.yang All the files in the yang folder were downloaded in this way. They are not strictly needed once generated.go has been created, but are kept here for convenience, saving to have to run the procedure above if a change was needed. If the generator program reports that a dependency was required e.g. openconfig-inet-types.yang then the version of this file with a date equal to or before 2017-07-14 should be downloaded - it is openconfig-inet-types@2017-07-14.yang","title":"OpenConfig Models"},{"location":"onos-config/docs/modelplugin/#readonly-paths-in-openconfig-models","text":"When an item in an Openconfig YANG file has \"config false\" it is effectively a read-only attribute. Usually with OpenConfig read-only objects are interspersed throughout the YANG model. To see a list of Read Only paths use the command: > onos config get plugins -v When the Model Plugin is loaded, setting of an attribute like state/address should give an appropriate error > gnmi_cli -address localhost:5150 -set \\ -proto \"update: <path: <target: 'localhost-1', elem: <name: 'system'> elem: <name: 'openflow'> elem: <name: 'controllers'> elem: <name: 'controller' key: <key: 'name' value: 'main'>> elem: <name: 'connections'> elem: <name: 'connection' key: <key: 'aux-id' value: '0'>> elem: <name: 'state'> elem: <name: 'address'>> val: <string_val: '192.0.2.11'>>\" \\ -timeout 5s -alsologtostderr \\ -client_crt pkg/southbound/testdata/client1.crt \\ -client_key pkg/southbound/testdata/client1.key \\ -ca_crt pkg/southbound/testdata/onfca.crt gives the error: rpc error: code = InvalidArgument desc = update contains a change to a read only path /system/openflow/controllers/controller[name=main]/connections/connection[aux-id=0]/state/address. Rejected","title":"Readonly paths in OpenConfig models"},{"location":"onos-config/docs/prerequisites/","text":"Development Prerequisites This document provides an overview of the tools and packages needed to work on and to build onos-config. Developers are expected to have these tools installed on the machine where the project is built. Go Tools Since the project is authored mainly in the Go programming language, the project requires Go tools in order to build and execute the code. Go Linters golangci-lint is required to validate that the Go source code complies with the established style guidelines. To install the tool, use this command: > curl -sfL https://install.goreleaser.com/github.com/golangci/golangci-lint.sh | sh -s -- -b $(go env GOPATH)/bin latest Docker Docker is required to build the project Docker images and also to compile *.proto files into Go source files. Local kubernetes environment Some form of local kubernetes development environment is also needed. The core team uses Kind , but there are other options such as Minikube . IDE Some form of an integrated development environment is also recommended. The core team uses the GoLand IDE from JetBrains, but there are many other options. Microsoft's Visual Studio Code is one such option and is available as a free download. Note that when using GoLand IDE you should enable integration with Go modules in Preferences -> Go -> Go Modules . License The project requires that all Go source files are properly annotated using the Apache 2.0 License. Since this requirement is enforced by the CI process, it is strongly recommended that developers setup their IDE to include the license text automatically. GoLand IDE can be easily setup to do this and other IDEs will have a similar mechanism.","title":"Development Prerequisites"},{"location":"onos-config/docs/prerequisites/#development-prerequisites","text":"This document provides an overview of the tools and packages needed to work on and to build onos-config. Developers are expected to have these tools installed on the machine where the project is built.","title":"Development Prerequisites"},{"location":"onos-config/docs/prerequisites/#go-tools","text":"Since the project is authored mainly in the Go programming language, the project requires Go tools in order to build and execute the code.","title":"Go Tools"},{"location":"onos-config/docs/prerequisites/#go-linters","text":"golangci-lint is required to validate that the Go source code complies with the established style guidelines. To install the tool, use this command: > curl -sfL https://install.goreleaser.com/github.com/golangci/golangci-lint.sh | sh -s -- -b $(go env GOPATH)/bin latest","title":"Go Linters"},{"location":"onos-config/docs/prerequisites/#docker","text":"Docker is required to build the project Docker images and also to compile *.proto files into Go source files.","title":"Docker"},{"location":"onos-config/docs/prerequisites/#local-kubernetes-environment","text":"Some form of local kubernetes development environment is also needed. The core team uses Kind , but there are other options such as Minikube .","title":"Local kubernetes environment"},{"location":"onos-config/docs/prerequisites/#ide","text":"Some form of an integrated development environment is also recommended. The core team uses the GoLand IDE from JetBrains, but there are many other options. Microsoft's Visual Studio Code is one such option and is available as a free download. Note that when using GoLand IDE you should enable integration with Go modules in Preferences -> Go -> Go Modules .","title":"IDE"},{"location":"onos-config/docs/prerequisites/#license","text":"The project requires that all Go source files are properly annotated using the Apache 2.0 License. Since this requirement is enforced by the CI process, it is strongly recommended that developers setup their IDE to include the license text automatically. GoLand IDE can be easily setup to do this and other IDEs will have a similar mechanism.","title":"License"},{"location":"onos-config/docs/pull_requests/","text":"Issues and Pull Requests The onos-config project uses GitHub Issues to track work items and bugs that were discovered. Instructions on this page show how to relate Issues to Pull Requests during the development workflow. Issues Issues are units of work to be done in the onos project and can represent new features to be developed or defects to be fixed. Find an Issue You can browse through the existing issues or you can search for a specific one. Open an Issue If you want to work on a new feature that is not yet tracked, please create a new issue to represent the work and assign it to an appropriate project, e.g. Core, Northbound. Work on an Issue After you found or created an issue to work on, you should: * assign that issue to yourself * go to the projects * select the project you have assigned the issue to * drag and drop the issue to the In Progress column to let people know that you are working on it Pull Requests This section describes how to open a pull request and assign it to one of the several projects in onos-config. Reference an Issue from Your Commit If you have an issue identifying your work in onos-config issues , To automatically link your pull request an issue, before pushing a commit to your fork of onos-config please insert fixes #<issue-number> into the commit message. The following is an example of a complete commit message: Adding pull request workflow Fixes #90 # Please enter the commit message for your changes. Lines starting # with '#' will be ignored, and an empty message aborts the commit. # # Date: Fri May 10 11:36:26 2019 +0200 # # On branch pr-process # Changes to be committed: # new file: docs/Pull_requests.md # # Changes not staged for commit: # modified: docs/Pull_requests.md # Open a Pull Request When you open a pull request for myfeature you need to add the PR to a project (e.g. Northbound) through the github UI. Please also assign a reviewer out of the suggested ones. If none are suggested please pick one from the core team. More information on opening pull requests can be found in the GitHub documentation . Track a Pull Request After your pull request is included into a onos-config project you can find it under the In Progress tab. At this point in time the PR will go through a lifecycle: * Review from different people --> your PR will go into Review in progress state * if changes are requested you will have to go back and address them * when your PR is approved and Testing is passed it will go under Reviewer approved state * after the PR is in Reviewer approved it can be merged * when the PR is merged both the PR and the issue will move under Done state","title":"Issues and Pull Requests"},{"location":"onos-config/docs/pull_requests/#issues-and-pull-requests","text":"The onos-config project uses GitHub Issues to track work items and bugs that were discovered. Instructions on this page show how to relate Issues to Pull Requests during the development workflow.","title":"Issues and Pull Requests"},{"location":"onos-config/docs/pull_requests/#issues","text":"Issues are units of work to be done in the onos project and can represent new features to be developed or defects to be fixed.","title":"Issues"},{"location":"onos-config/docs/pull_requests/#find-an-issue","text":"You can browse through the existing issues or you can search for a specific one.","title":"Find an Issue"},{"location":"onos-config/docs/pull_requests/#open-an-issue","text":"If you want to work on a new feature that is not yet tracked, please create a new issue to represent the work and assign it to an appropriate project, e.g. Core, Northbound.","title":"Open an Issue"},{"location":"onos-config/docs/pull_requests/#work-on-an-issue","text":"After you found or created an issue to work on, you should: * assign that issue to yourself * go to the projects * select the project you have assigned the issue to * drag and drop the issue to the In Progress column to let people know that you are working on it","title":"Work on an Issue"},{"location":"onos-config/docs/pull_requests/#pull-requests","text":"This section describes how to open a pull request and assign it to one of the several projects in onos-config.","title":"Pull Requests"},{"location":"onos-config/docs/pull_requests/#reference-an-issue-from-your-commit","text":"If you have an issue identifying your work in onos-config issues , To automatically link your pull request an issue, before pushing a commit to your fork of onos-config please insert fixes #<issue-number> into the commit message. The following is an example of a complete commit message: Adding pull request workflow Fixes #90 # Please enter the commit message for your changes. Lines starting # with '#' will be ignored, and an empty message aborts the commit. # # Date: Fri May 10 11:36:26 2019 +0200 # # On branch pr-process # Changes to be committed: # new file: docs/Pull_requests.md # # Changes not staged for commit: # modified: docs/Pull_requests.md #","title":"Reference an Issue from Your Commit"},{"location":"onos-config/docs/pull_requests/#open-a-pull-request","text":"When you open a pull request for myfeature you need to add the PR to a project (e.g. Northbound) through the github UI. Please also assign a reviewer out of the suggested ones. If none are suggested please pick one from the core team. More information on opening pull requests can be found in the GitHub documentation .","title":"Open a Pull Request"},{"location":"onos-config/docs/pull_requests/#track-a-pull-request","text":"After your pull request is included into a onos-config project you can find it under the In Progress tab. At this point in time the PR will go through a lifecycle: * Review from different people --> your PR will go into Review in progress state * if changes are requested you will have to go back and address them * when your PR is approved and Testing is passed it will go under Reviewer approved state * after the PR is in Reviewer approved it can be merged * when the PR is merged both the PR and the issue will move under Done state","title":"Track a Pull Request"},{"location":"onos-config/docs/run/","text":"Running onos-config The commands shown below can be run from anywhere on your PC provided that go tools are installed and the GOPATH environment variable is set, e.g. export GOPATH=~/go Run with Helm charts onos-config can run through Helm Charts as defined in the deployment.md page. Running with Helm is Work in Progress Run with onit onos-config can run through the onit tool. You can find more information on how to setup onit in the setup.md page, and how to run onit at run.md Loading Model Plugins The model-plugin for your device can be built and loaded as outlined in the modelplugins.md guide. When running with Docker or Kubernetes these plugins will be built and (optionally) loaded at startup. To check the list of currently loaded plugins use: > onos config get plugins Northbound gNMI service The system provides a full implementation of the gNMI spec as a northbound service. On a deployed cluster the onos-cli pod has a gNMI client that can be used to format and send gNMI messages. To access the CLI use onit onos-cli to get in to the onos-cli pod and then run gnmi_cli from there. Here is an example on how to use gnmi_cli -get to get configuration for a particular device (target) from the system. > gnmi_cli -get -address onos-config:5150 \\ -proto \"path: <target: 'localhost-1', elem: <name: 'system'> elem:<name:'config'> elem: <name: 'motd-banner'>>\" \\ -timeout 5s -alsologtostderr \\ -client_crt /etc/ssl/certs/client1.crt \\ -client_key /etc/ssl/certs/client1.key \\ -ca_crt /etc/ssl/certs/onfca.crt Full list of the gNMI northbound endpoints Administrative and Diagnostic Tools The project provides enhanced northbound functionality though administrative and diagnostic tools, which are integrated into the consolidated onos command. For example, to list all network changes submitted through the northbound gNMI interface run: > onos config get net-changes Or, run the following to list all changes submitted through the northbound gNMI as they are tracked by the system broken-up into device specific batches: > onos config get changes You can read more comprehensive documentation of the various administrative and diagnostic commands .","title":"Running onos-config"},{"location":"onos-config/docs/run/#running-onos-config","text":"The commands shown below can be run from anywhere on your PC provided that go tools are installed and the GOPATH environment variable is set, e.g. export GOPATH=~/go","title":"Running onos-config"},{"location":"onos-config/docs/run/#run-with-helm-charts","text":"onos-config can run through Helm Charts as defined in the deployment.md page. Running with Helm is Work in Progress","title":"Run with Helm charts"},{"location":"onos-config/docs/run/#run-with-onit","text":"onos-config can run through the onit tool. You can find more information on how to setup onit in the setup.md page, and how to run onit at run.md","title":"Run with onit"},{"location":"onos-config/docs/run/#loading-model-plugins","text":"The model-plugin for your device can be built and loaded as outlined in the modelplugins.md guide. When running with Docker or Kubernetes these plugins will be built and (optionally) loaded at startup. To check the list of currently loaded plugins use: > onos config get plugins","title":"Loading Model Plugins"},{"location":"onos-config/docs/run/#northbound-gnmi-service","text":"The system provides a full implementation of the gNMI spec as a northbound service. On a deployed cluster the onos-cli pod has a gNMI client that can be used to format and send gNMI messages. To access the CLI use onit onos-cli to get in to the onos-cli pod and then run gnmi_cli from there. Here is an example on how to use gnmi_cli -get to get configuration for a particular device (target) from the system. > gnmi_cli -get -address onos-config:5150 \\ -proto \"path: <target: 'localhost-1', elem: <name: 'system'> elem:<name:'config'> elem: <name: 'motd-banner'>>\" \\ -timeout 5s -alsologtostderr \\ -client_crt /etc/ssl/certs/client1.crt \\ -client_key /etc/ssl/certs/client1.key \\ -ca_crt /etc/ssl/certs/onfca.crt Full list of the gNMI northbound endpoints","title":"Northbound gNMI service"},{"location":"onos-config/docs/run/#administrative-and-diagnostic-tools","text":"The project provides enhanced northbound functionality though administrative and diagnostic tools, which are integrated into the consolidated onos command. For example, to list all network changes submitted through the northbound gNMI interface run: > onos config get net-changes Or, run the following to list all changes submitted through the northbound gNMI as they are tracked by the system broken-up into device specific batches: > onos config get changes You can read more comprehensive documentation of the various administrative and diagnostic commands .","title":"Administrative and Diagnostic Tools"},{"location":"onos-config/modelplugin/yang/","text":"YANG store All files in this folder should be named in the format \\ @\\ .yang . See modelplugins.md for more details.","title":"YANG store"},{"location":"onos-config/modelplugin/yang/#yang-store","text":"All files in this folder should be named in the format \\ @\\ .yang . See modelplugins.md for more details.","title":"YANG store"},{"location":"onos-test/","text":"ONIT: An Integration test infrastructure for ONOS (\u00b5ONOS Architecture) The onos project provides an integration testing framework for running end-to-end tests on Kubernetes . This document describes the process for managing a development/test environment and running integration tests with onit . Additional Documents How to install and run onit How to use onit How to test onos subsystems","title":"Index"},{"location":"onos-test/#onit-an-integration-test-infrastructure-for-onos-onos-architecture","text":"The onos project provides an integration testing framework for running end-to-end tests on Kubernetes . This document describes the process for managing a development/test environment and running integration tests with onit .","title":"ONIT: An Integration test infrastructure for ONOS (\u00b5ONOS Architecture)"},{"location":"onos-test/#additional-documents","text":"How to install and run onit How to use onit How to test onos subsystems","title":"Additional Documents"},{"location":"onos-test/docs/run/","text":"How To Use ONIT? The primary interface for setting up test clusters and running tests is the onit command, which provides a suite of commands for setting up and tearing down test clusters, adding and removing device simulators , adding and removing networks of [stratum] switches, adding and removing applications, running tests, and viewing test history. To see list of onit commands run onit from the shell as follows: > onit Run onos integration tests on Kubernetes Usage: onit [command] Available Commands: add Add resources to the cluster completion Generated bash or zsh auto-completion script create Create a test resource on Kubernetes debug Open a debugger port to the given resource delete Delete Kubernetes test resources fetch Fetch resources from the cluster get Get test configurations help Help about any command onos-cli Open onos-cli shell for executing commands remove Remove resources from the cluster run Run integration tests set Set test configurations ssh Open a ssh session to a node for executing remote commands Flags: -h, --help help for onit Use \"onit [command] --help\" for more information about a command. Cluster Setup The first step to running tests is to setup a test cluster with onit create cluster : > onit create cluster \u2713 Creating cluster namespace \u2713 Setting up RBAC \u2713 Setting up Atomix controller \u2713 Starting Raft partitions \u2713 Adding secrets \u2713 Bootstrapping onos-topo cluster \u2713 Bootstrapping onos-config cluster \u2713 Setting up GUI \u2713 Setting up CLI \u2713 Creating ingress for services cluster-8face0a8-bed6-11e9-a853-3c15c2cff232 You can also specify the number of nodes for each onos subsystem, for example, to create a cluster which runs two onos-config and two onos-topo pods, run the following command: onit create cluster onit-1 --config-nodes 2 --topo-nodes 2 To setup the cluster, onit creates a unique namespace within which to create test resources, deploys Atomix inside the test namespace, and configures and deploys onos-config nodes. Once the cluster is setup, the command will output the name of the test namespace. The namespace can be used to view test resources via kubectl : > kubectl get pods -n cluster-8face0a8-bed6-11e9-a853-3c15c2cff232 NAME READY STATUS RESTARTS AGE atomix-controller-7f95d69f47-sbsn4 1/1 Running 0 107s onos-cli-6c6cf7cc89-fmvwq 1/1 Running 0 63s onos-config-d68456bd7-xf9nv 1/1 Running 0 72s onos-config-envoy-5c49b74dc4-vpmm4 1/1 Running 0 71s onos-gui-6c78895d94-lj5vq 1/1 Running 0 65s onos-topo-654999644-674z5 1/1 Running 0 87s onos-topo-envoy-dcddf9dc6-2f5q9 1/1 Running 0 87s raft-1-0 1/1 Running 0 98s The create cluster command supports additional flags for defining the cluster architecture: Flags: -c, --config string test cluster configuration (default \"default\") --config-nodes int the number of onos-config nodes to deploy (default 1) --docker-registry string an optional host:port for a private Docker registry -h, --help help for cluster --image-pull-policy string the Docker image pull policy (default \"IfNotPresent\") --image-tags stringToString the image docker container tag for each node in the cluster (default [topo=debug,simulator=latest,stratum=latest,test=latest,atomix=latest,raft=latest,config=debug]) -s, --partition-size int the size of each Raft partition (default 1) -p, --partitions int the number of Raft partitions to deploy (default 1) --topo-nodes int the number of onos-topo nodes to deploy (default 1) Once the cluster is setup, the cluster configuration will be added to the onit configuration and the deployed cluster will be set as the current cluster context: > onit get cluster cluster-b8c45834-a81c-11e9-82f4-3c15c2cff232 You can also create a cluster by passing a name to the onit create cluster command. To create a cluster with name onit-2 , we run the following command: > onit create cluster onit-1 onit create cluster onit-1 \u2713 Creating cluster namespace \u2713 Setting up RBAC \u2713 Setting up Atomix controller \u2713 Starting Raft partitions \u2713 Adding secrets \u2713 Bootstrapping onos-topo cluster \u2713 Bootstrapping onos-config cluster \u2713 Setting up GUI \u2713 Setting up CLI \u2713 Creating ingress for services onit-1 if we run onit get clusters command, we should be able to see the two clusters that we created: > onit get clusters ID SIZE PARTITIONS cluster-b8c45834-a81c-11e9-82f4-3c15c2cff232 1 1 onit-1 When multiple clusters are deployed, you can switch between clusters by setting the current cluster context: > onit set cluster onit-1 onit-1 This will run all future cluster operations on the configured cluster. Alternatively, most commands support a flag to override the default cluster. You can also use set command to redeploy a deployment with a new container image. For example, to redeploy onos-config subsystem with a new debug image, you can run the following command: onit set image onos-config --image onosproject/onos-config:debug To delete a cluster, run onit delete cluster : > onit delete cluster \u2713 Deleting cluster namespace Adding Simulators Most tests require devices to be added to the cluster. The onit command supports adding and removing device simulators through the add and remove commands. To add a simulator to the current cluster, simply run onit add simulator : > onit add simulator \u2713 Setting up simulator \u2713 Reconfiguring onos-config nodes device-1186885096 When a simulator is added to the cluster, the cluster is reconfigured in two phases: * Bootstrap a new device simulator with the provided configuration * Reconfigure and redeploy the onos-config cluster with the new device in its stores To give a name to a simulator, pass a name to onit add simulator command as follows > onit add simulator sim-2 \u2713 Setting up simulator \u2713 Reconfiguring onos-config nodes sim-2 To get list of simulators, run onit get simulators as follows: > onit get simulators device-1186885096 sim-2 Simulators can similarly be removed with the remove simulator command: > onit remove simulator device-1186885096 \u2713 Tearing down simulator \u2713 Reconfiguring onos-config nodes As with the add command, removing a simulator requires that the onos-config cluster be reconfigured and redeployed. Adding Networks To run some of the tests on stratum switches, we can create a network of stratum switches using Mininet. To create a network of stratum switches, we can use onit add network [Name] [Mininet Options] as follows: To create a single node network, simply run onit add network . This command creates a single node network and assigns a name to it automatically. To create a linear network topology with two switches and name it stratum-linear , simply run the following command: > onit add network stratum-linear -- --topo linear,2 \u2713 Setting up network \u2713 Reconfiguring onos-config nodes stratum-linear When a network is added to the cluster, the cluster is reconfigured in two phases: * Bootstrap one or more than one new stratum switches with the provided configuration * Reconfigure and redeploy the onos-config cluster with the new switches in its stores To add a single node network topology, run the following command: > onit add network \u2713 Setting up network \u2713 Reconfiguring onos-config nodes network-2878434070 To get list of networks, run the following command: > onit get networks network-2878434070 stratum-linear Networks can be removed using onit remove network command. For example, to remove the linear topolog that is created using the above command, you should run the following command: > onit remove network stratum-linear \u2713 Tearing down network \u2713 Reconfiguring onos-config nodes As with the add command, removing a network requires that the onos-config cluster be reconfigured and redeployed. Note : In the current implementation, we support the following network topologies: A Single node network topology A Linear network topology Adding Applications Applications from outside of onit can be added to an onit cluster using the onit add app command. This command takes the name of the app as an argument. It also has the --image flag that allows a user to specify the image of the application that should be deployed. The user also can specify the pull policy for the image using --image-pull-policy flag. For example, to deploy the latest version of the onos-ztp application: > onit add app onos-ztp --image onosproject/onos-ztp:latest --image-pull-policy \"Always\" \u2713 Setting up app onos-ztp To give a name to an app, pass a name to the onit add app command as follows > onit add app onosproject/onos-ztp:latest ztp \u2713 Setting up app ztp To get list of apps, run onit get apps as follows: > onit get apps app-128922186 Apps can be removed with the remove app command: > onit remove app app-128922186 \u2713 Tearing down app SSH Into A Cluster Node onit allows you to ssh into a node using the following command: onit ssh <name of a node> onit also provides a command that you can run onos-cli commands via onit as follows: onit onos-cli ~ $ onos ONOS command line client Usage: onos [command] Available Commands: completion Generated bash or zsh auto-completion script help Help about any command topo ztp ONOS zero-touch provisioning subsystem commands Flags: -h, --help help for onos Use \"onos [command] --help\" for more information about a command.","title":"Run"},{"location":"onos-test/docs/run/#how-to-use-onit","text":"The primary interface for setting up test clusters and running tests is the onit command, which provides a suite of commands for setting up and tearing down test clusters, adding and removing device simulators , adding and removing networks of [stratum] switches, adding and removing applications, running tests, and viewing test history. To see list of onit commands run onit from the shell as follows: > onit Run onos integration tests on Kubernetes Usage: onit [command] Available Commands: add Add resources to the cluster completion Generated bash or zsh auto-completion script create Create a test resource on Kubernetes debug Open a debugger port to the given resource delete Delete Kubernetes test resources fetch Fetch resources from the cluster get Get test configurations help Help about any command onos-cli Open onos-cli shell for executing commands remove Remove resources from the cluster run Run integration tests set Set test configurations ssh Open a ssh session to a node for executing remote commands Flags: -h, --help help for onit Use \"onit [command] --help\" for more information about a command.","title":"How To Use ONIT?"},{"location":"onos-test/docs/run/#cluster-setup","text":"The first step to running tests is to setup a test cluster with onit create cluster : > onit create cluster \u2713 Creating cluster namespace \u2713 Setting up RBAC \u2713 Setting up Atomix controller \u2713 Starting Raft partitions \u2713 Adding secrets \u2713 Bootstrapping onos-topo cluster \u2713 Bootstrapping onos-config cluster \u2713 Setting up GUI \u2713 Setting up CLI \u2713 Creating ingress for services cluster-8face0a8-bed6-11e9-a853-3c15c2cff232 You can also specify the number of nodes for each onos subsystem, for example, to create a cluster which runs two onos-config and two onos-topo pods, run the following command: onit create cluster onit-1 --config-nodes 2 --topo-nodes 2 To setup the cluster, onit creates a unique namespace within which to create test resources, deploys Atomix inside the test namespace, and configures and deploys onos-config nodes. Once the cluster is setup, the command will output the name of the test namespace. The namespace can be used to view test resources via kubectl : > kubectl get pods -n cluster-8face0a8-bed6-11e9-a853-3c15c2cff232 NAME READY STATUS RESTARTS AGE atomix-controller-7f95d69f47-sbsn4 1/1 Running 0 107s onos-cli-6c6cf7cc89-fmvwq 1/1 Running 0 63s onos-config-d68456bd7-xf9nv 1/1 Running 0 72s onos-config-envoy-5c49b74dc4-vpmm4 1/1 Running 0 71s onos-gui-6c78895d94-lj5vq 1/1 Running 0 65s onos-topo-654999644-674z5 1/1 Running 0 87s onos-topo-envoy-dcddf9dc6-2f5q9 1/1 Running 0 87s raft-1-0 1/1 Running 0 98s The create cluster command supports additional flags for defining the cluster architecture: Flags: -c, --config string test cluster configuration (default \"default\") --config-nodes int the number of onos-config nodes to deploy (default 1) --docker-registry string an optional host:port for a private Docker registry -h, --help help for cluster --image-pull-policy string the Docker image pull policy (default \"IfNotPresent\") --image-tags stringToString the image docker container tag for each node in the cluster (default [topo=debug,simulator=latest,stratum=latest,test=latest,atomix=latest,raft=latest,config=debug]) -s, --partition-size int the size of each Raft partition (default 1) -p, --partitions int the number of Raft partitions to deploy (default 1) --topo-nodes int the number of onos-topo nodes to deploy (default 1) Once the cluster is setup, the cluster configuration will be added to the onit configuration and the deployed cluster will be set as the current cluster context: > onit get cluster cluster-b8c45834-a81c-11e9-82f4-3c15c2cff232 You can also create a cluster by passing a name to the onit create cluster command. To create a cluster with name onit-2 , we run the following command: > onit create cluster onit-1 onit create cluster onit-1 \u2713 Creating cluster namespace \u2713 Setting up RBAC \u2713 Setting up Atomix controller \u2713 Starting Raft partitions \u2713 Adding secrets \u2713 Bootstrapping onos-topo cluster \u2713 Bootstrapping onos-config cluster \u2713 Setting up GUI \u2713 Setting up CLI \u2713 Creating ingress for services onit-1 if we run onit get clusters command, we should be able to see the two clusters that we created: > onit get clusters ID SIZE PARTITIONS cluster-b8c45834-a81c-11e9-82f4-3c15c2cff232 1 1 onit-1 When multiple clusters are deployed, you can switch between clusters by setting the current cluster context: > onit set cluster onit-1 onit-1 This will run all future cluster operations on the configured cluster. Alternatively, most commands support a flag to override the default cluster. You can also use set command to redeploy a deployment with a new container image. For example, to redeploy onos-config subsystem with a new debug image, you can run the following command: onit set image onos-config --image onosproject/onos-config:debug To delete a cluster, run onit delete cluster : > onit delete cluster \u2713 Deleting cluster namespace","title":"Cluster Setup"},{"location":"onos-test/docs/run/#adding-simulators","text":"Most tests require devices to be added to the cluster. The onit command supports adding and removing device simulators through the add and remove commands. To add a simulator to the current cluster, simply run onit add simulator : > onit add simulator \u2713 Setting up simulator \u2713 Reconfiguring onos-config nodes device-1186885096 When a simulator is added to the cluster, the cluster is reconfigured in two phases: * Bootstrap a new device simulator with the provided configuration * Reconfigure and redeploy the onos-config cluster with the new device in its stores To give a name to a simulator, pass a name to onit add simulator command as follows > onit add simulator sim-2 \u2713 Setting up simulator \u2713 Reconfiguring onos-config nodes sim-2 To get list of simulators, run onit get simulators as follows: > onit get simulators device-1186885096 sim-2 Simulators can similarly be removed with the remove simulator command: > onit remove simulator device-1186885096 \u2713 Tearing down simulator \u2713 Reconfiguring onos-config nodes As with the add command, removing a simulator requires that the onos-config cluster be reconfigured and redeployed.","title":"Adding Simulators"},{"location":"onos-test/docs/run/#adding-networks","text":"To run some of the tests on stratum switches, we can create a network of stratum switches using Mininet. To create a network of stratum switches, we can use onit add network [Name] [Mininet Options] as follows: To create a single node network, simply run onit add network . This command creates a single node network and assigns a name to it automatically. To create a linear network topology with two switches and name it stratum-linear , simply run the following command: > onit add network stratum-linear -- --topo linear,2 \u2713 Setting up network \u2713 Reconfiguring onos-config nodes stratum-linear When a network is added to the cluster, the cluster is reconfigured in two phases: * Bootstrap one or more than one new stratum switches with the provided configuration * Reconfigure and redeploy the onos-config cluster with the new switches in its stores To add a single node network topology, run the following command: > onit add network \u2713 Setting up network \u2713 Reconfiguring onos-config nodes network-2878434070 To get list of networks, run the following command: > onit get networks network-2878434070 stratum-linear Networks can be removed using onit remove network command. For example, to remove the linear topolog that is created using the above command, you should run the following command: > onit remove network stratum-linear \u2713 Tearing down network \u2713 Reconfiguring onos-config nodes As with the add command, removing a network requires that the onos-config cluster be reconfigured and redeployed. Note : In the current implementation, we support the following network topologies: A Single node network topology A Linear network topology","title":"Adding Networks"},{"location":"onos-test/docs/run/#adding-applications","text":"Applications from outside of onit can be added to an onit cluster using the onit add app command. This command takes the name of the app as an argument. It also has the --image flag that allows a user to specify the image of the application that should be deployed. The user also can specify the pull policy for the image using --image-pull-policy flag. For example, to deploy the latest version of the onos-ztp application: > onit add app onos-ztp --image onosproject/onos-ztp:latest --image-pull-policy \"Always\" \u2713 Setting up app onos-ztp To give a name to an app, pass a name to the onit add app command as follows > onit add app onosproject/onos-ztp:latest ztp \u2713 Setting up app ztp To get list of apps, run onit get apps as follows: > onit get apps app-128922186 Apps can be removed with the remove app command: > onit remove app app-128922186 \u2713 Tearing down app","title":"Adding Applications"},{"location":"onos-test/docs/run/#ssh-into-a-cluster-node","text":"onit allows you to ssh into a node using the following command: onit ssh <name of a node> onit also provides a command that you can run onos-cli commands via onit as follows: onit onos-cli ~ $ onos ONOS command line client Usage: onos [command] Available Commands: completion Generated bash or zsh auto-completion script help Help about any command topo ztp ONOS zero-touch provisioning subsystem commands Flags: -h, --help help for onos Use \"onos [command] --help\" for more information about a command.","title":"SSH Into A Cluster Node"},{"location":"onos-test/docs/setup/","text":"How To Install and Run ONIT? Setup The integration test framework is designed to operate on a Kubernetes cluster. It's recommended that users use a local Kubernetes cluster suitable for development, e.g. [Minikube], [kind], or [MicroK8s]. To run onit , you need to install go tools on your machine as explained here Configuration The test framework is controlled through the onit command. To install the onit command, use go get : export $GO111MODULE=on > go get github.com/onosproject/onos-test/cmd/onit To interact with a Kubernetes cluster, the onit command must have access to a local Kubernetes configuration. Onit expects the same configuration as kubectl and will connect to the same Kubernetes cluster as kubectl will connect to, so to determine which Kubernetes cluster onit will use, simply run kubectl cluster-info : > kubectl cluster-info Kubernetes master is running at https://127.0.0.1:49760 KubeDNS is running at https://127.0.0.1:49760/api/v1/namespaces/kube-system/services/kube-dns:dns/proxy See the Kubernetes documentation for details on configuring both kubectl and onit to connect to a new cluster or multiple clusters. The onit command also maintains some cluster metadata in a local configuration file. The search path for the onit.yaml configuration file is: * ~/.onos * /etc/onos * . Users do not typically need to modify the onit.yaml configuration file directly. The onit configuration is primarily managed through various onit commands like onit set , onit create , onit add , etc. It's recommended that users avoid modifying the onit configuration file, but it's nevertheless important to note that the application must have write access to one of the above paths. Onit Auto-Completion Onit supports shell auto-completion for its various commands, sub-commands and flags. You can enable this feature for bash or zsh as follows: Bash Auto-Completion To enable this for bash , run the following from the shell: > eval \"$(onit completion bash)\" Zsh Auto-Completion To enable this for zsh , run the following from the shell: > source <(onit completion zsh) Note : We also recommend to add the output of the above commands to .bashrc or .zshrc . Docker The onit command manages clusters and runs tests by deploying locally built [Docker] containers on [Kubernetes]. Docker image builds are an essential component of the onit workflow. Each time a change is made to either the core or integration tests, Docker images must be rebuilt and made available within the Kubernetes cluster in which tests are being run. The precise process for building Docker images and adding them to a local Kubernetes cluster is different for each setup. Building for Minikube [Minikube] runs a VM with its own Docker daemon running inside it. To build the Docker images for Minikube, ensure you use configure your shell to use Minikube Docker context before building: > eval $(minikube docker-env) Once the shell has been configured, use make images to build the Docker images: > make images Note that make images must be run every time a change is made to either the core code or integration tests. Building for Kind [Kind][kind] provides an alternative to [Minikube] which runs Kubernetes in a Docker container. Assuming you have dowloaded kind as per [instructions][kind-install], the first time you boot the kind cluster or if you have rebooted your docker deamon you need to issue: > kind create cluster and for each window you intend to use onit commands in you will need to export the KUBECONFIG variable: > export KUBECONFIG=\"$(kind get kubeconfig-path --name=\"kind\")\" As with Minikube, kind requires specific setup to ensure Docker images modified and built locally can be run within the kind cluster. Rather than switching your Docker environment to a remote Docker server, kind requires that images be explicitly loaded into the cluster each time they're built. For this reason, we provide a convenience make target: kind : > make kind When the kind target is run, the onos-config and onos-config-integration-tests images will be built and loaded into the kind cluster, so no additional step is necessary.","title":"How To Install and Run ONIT?"},{"location":"onos-test/docs/setup/#how-to-install-and-run-onit","text":"","title":"How To Install and Run ONIT?"},{"location":"onos-test/docs/setup/#setup","text":"The integration test framework is designed to operate on a Kubernetes cluster. It's recommended that users use a local Kubernetes cluster suitable for development, e.g. [Minikube], [kind], or [MicroK8s]. To run onit , you need to install go tools on your machine as explained here","title":"Setup"},{"location":"onos-test/docs/setup/#configuration","text":"The test framework is controlled through the onit command. To install the onit command, use go get : export $GO111MODULE=on > go get github.com/onosproject/onos-test/cmd/onit To interact with a Kubernetes cluster, the onit command must have access to a local Kubernetes configuration. Onit expects the same configuration as kubectl and will connect to the same Kubernetes cluster as kubectl will connect to, so to determine which Kubernetes cluster onit will use, simply run kubectl cluster-info : > kubectl cluster-info Kubernetes master is running at https://127.0.0.1:49760 KubeDNS is running at https://127.0.0.1:49760/api/v1/namespaces/kube-system/services/kube-dns:dns/proxy See the Kubernetes documentation for details on configuring both kubectl and onit to connect to a new cluster or multiple clusters. The onit command also maintains some cluster metadata in a local configuration file. The search path for the onit.yaml configuration file is: * ~/.onos * /etc/onos * . Users do not typically need to modify the onit.yaml configuration file directly. The onit configuration is primarily managed through various onit commands like onit set , onit create , onit add , etc. It's recommended that users avoid modifying the onit configuration file, but it's nevertheless important to note that the application must have write access to one of the above paths.","title":"Configuration"},{"location":"onos-test/docs/setup/#onit-auto-completion","text":"Onit supports shell auto-completion for its various commands, sub-commands and flags. You can enable this feature for bash or zsh as follows:","title":"Onit Auto-Completion"},{"location":"onos-test/docs/setup/#bash-auto-completion","text":"To enable this for bash , run the following from the shell: > eval \"$(onit completion bash)\"","title":"Bash Auto-Completion"},{"location":"onos-test/docs/setup/#zsh-auto-completion","text":"To enable this for zsh , run the following from the shell: > source <(onit completion zsh) Note : We also recommend to add the output of the above commands to .bashrc or .zshrc .","title":"Zsh Auto-Completion"},{"location":"onos-test/docs/setup/#docker","text":"The onit command manages clusters and runs tests by deploying locally built [Docker] containers on [Kubernetes]. Docker image builds are an essential component of the onit workflow. Each time a change is made to either the core or integration tests, Docker images must be rebuilt and made available within the Kubernetes cluster in which tests are being run. The precise process for building Docker images and adding them to a local Kubernetes cluster is different for each setup.","title":"Docker"},{"location":"onos-test/docs/setup/#building-for-minikube","text":"[Minikube] runs a VM with its own Docker daemon running inside it. To build the Docker images for Minikube, ensure you use configure your shell to use Minikube Docker context before building: > eval $(minikube docker-env) Once the shell has been configured, use make images to build the Docker images: > make images Note that make images must be run every time a change is made to either the core code or integration tests.","title":"Building for Minikube"},{"location":"onos-test/docs/setup/#building-for-kind","text":"[Kind][kind] provides an alternative to [Minikube] which runs Kubernetes in a Docker container. Assuming you have dowloaded kind as per [instructions][kind-install], the first time you boot the kind cluster or if you have rebooted your docker deamon you need to issue: > kind create cluster and for each window you intend to use onit commands in you will need to export the KUBECONFIG variable: > export KUBECONFIG=\"$(kind get kubeconfig-path --name=\"kind\")\" As with Minikube, kind requires specific setup to ensure Docker images modified and built locally can be run within the kind cluster. Rather than switching your Docker environment to a remote Docker server, kind requires that images be explicitly loaded into the cluster each time they're built. For this reason, we provide a convenience make target: kind : > make kind When the kind target is run, the onos-config and onos-config-integration-tests images will be built and loaded into the kind cluster, so no additional step is necessary.","title":"Building for Kind"},{"location":"onos-test/docs/testing/","text":"Running Tests Running single Tests Once the cluster has been setup for the test, to run a test simply use onit run : > onit run test single-path \u2713 Starting test job: test-25324770 === RUN single-path --- PASS: single-path (0.46s) PASS PASS You can specify as many tests as desired: > onit run test single-path transaction subscribe ... Running a suite of Tests onit can also run a suite of tests e.g. integration-tests which encompasses all the active integration tests. > onit run suite integration-tests \u2713 Starting test job: test-3109317976 === RUN single-path --- PASS: single-path (0.20s) === RUN subscribe --- PASS: subscribe (0.09s) PASS Test Run logs Each test run is recorded as a job in the Kubernetes cluster. This ensures that logs, statuses, and exit codes are retained for the lifetime of the cluster. Onit supports viewing past test runs and logs via the get command: > onit get history ID TESTS STATUS EXIT CODE MESSAGE test-25324770 test,single-path PASSED 0 test-2886892866 test,subscribe PASSED 0 test-3109317976 suite,integration-tests PASSED 0 To get the logs from a specific test, use onit get logs with the test ID: > onit get logs test-2886892866 === RUN test-single-path-test --- PASS: test-single-path-test (0.04s) PASS Debugging The onit command provides a set of commands for debugging test clusters. The onit command can be used to get logs for every resource deployed in the test cluster. Simply pass the resource ID (e.g. test ID , node ID , partition ID , etc) to the onit get logs command to get the logs for a resource. To list all types of nodes (e.g. onos-topo, onos-config, etc) running in the cluster, use onit get nodes , the output will be like the following: > onit get nodes onit get nodes ID TYPE STATUS onos-topo-7cd788fb7f-2zvsp topo RUNNING onos-topo-7cd788fb7f-rc6m5 topo RUNNING onos-config-6f8fcf5954-55zn2 config RUNNING onos-config-6f8fcf5954-pglkz config RUNNING To get logs for the above node, run the following command: > onit get logs onos-config-569c7d8546-jscg8 I0625 21:55:32.027255 1 onos-config.go:114] Starting onos-config I0625 21:55:32.030184 1 manager.go:98] Configuration store loaded from /etc/onos-config/configs/configStore.json I0625 21:55:32.030358 1 manager.go:105] Change store loaded from /etc/onos-config/configs/changeStore.json I0625 21:55:32.031087 1 manager.go:112] Device store loaded from /etc/onos-config/configs/deviceStore.json I0625 21:55:32.031222 1 manager.go:119] Network store loaded from /etc/onos-config/configs/networkStore.json I0625 21:55:32.031301 1 manager.go:47] Creating Manager ... To list the Raft partitions running in the cluster, use onit get partitions : > onit get partitions ID GROUP NODES 1 raft raft-1-0 To get logs for the above partions, run the following command: > onit get logs raft-1-0 21:10:24.466 [main] INFO io.atomix.server.AtomixServerRunner - Node ID: raft-1-0 21:10:24.472 [main] INFO io.atomix.server.AtomixServerRunner - Partition Config: /etc/atomix/partition.json 21:10:24.472 [main] INFO io.atomix.server.AtomixServerRunner - Protocol Config: /etc/atomix/protocol.json 21:10:24.473 [main] INFO io.atomix.server.AtomixServerRunner - Starting server ... To list the tests that have been run, use onit get history : > onit get history ID TESTS STATUS EXIT CODE MESSAGE 3cf7311a-9776-11e9-bfc3-acde48001122 test-integration-test PASSED 0 68ad9154-977c-11e9-bcf2-acde48001122 test-integration-test FAILED 1 71a0623c-977c-11e9-8478-acde48001122 test-single-path-test PASSED 0 9e512cdc-9720-11e9-ba6e-acde48001122 * PASSED 0 da629d06-9774-11e9-bb50-acde48001122 * PASSED 0 To get logs for one of the above histories, run the following command: > onit get logs 71a0623c-977c-11e9-8478-acde48001122 === RUN test-single-path-test --- PASS: test-single-path-test (0.04s) PASS To download logs from a node, you can run onit fetch logs command. For example, to download logs from onos-config-66d54956f5-xwpsh node, run the following command: onit fetch logs onos-config-66d54956f5-xwpsh You can refer to Debug onos-config in Onit Using Delve to learn more about debugging of onos-config pod using Delve debugger. API Tests are implemented using Go's testing package; func MyTest(t *testing.T) { t.Fail(\"you messed up!\") } However, rather than running tests using go test , we provide a custom registry of tests to allow human-readable names to be assigned to tests for ease of use. Once you've written a test, register the test in an init function: func init() { Registry.Register(\"my-test\", MyTest) } Once a test has been registered, you should be able to see the test via the onit command: > onit get tests my-test ... The test framework also provides the capability of adding your test to a suite defined in suites.go . To see the suites you can execute: > onit get suites SUITE TESTS alltests single-path, subscribe, transaction sometests subscribe, transaction integration-tests single-path To add your test to a suite in the init function the register method must be called with the suites parameter: func init() { Registry.RegisterTest(\"my-test\", MyTest, []*runner.TestSuite{AllTests}) } The test framework provides utility functions for creating clients and other resources within the test environment. The test environment is provided by the env package: client, err := env.NewGnmiClient(context.Background(), \"\") ... When devices are deployed in the test configuration, a list of device IDs can be retrieved from the environment: devices := env.GetDevices() onos onos-test","title":"Running Tests"},{"location":"onos-test/docs/testing/#running-tests","text":"","title":"Running Tests"},{"location":"onos-test/docs/testing/#running-single-tests","text":"Once the cluster has been setup for the test, to run a test simply use onit run : > onit run test single-path \u2713 Starting test job: test-25324770 === RUN single-path --- PASS: single-path (0.46s) PASS PASS You can specify as many tests as desired: > onit run test single-path transaction subscribe ...","title":"Running single Tests"},{"location":"onos-test/docs/testing/#running-a-suite-of-tests","text":"onit can also run a suite of tests e.g. integration-tests which encompasses all the active integration tests. > onit run suite integration-tests \u2713 Starting test job: test-3109317976 === RUN single-path --- PASS: single-path (0.20s) === RUN subscribe --- PASS: subscribe (0.09s) PASS","title":"Running a suite of Tests"},{"location":"onos-test/docs/testing/#test-run-logs","text":"Each test run is recorded as a job in the Kubernetes cluster. This ensures that logs, statuses, and exit codes are retained for the lifetime of the cluster. Onit supports viewing past test runs and logs via the get command: > onit get history ID TESTS STATUS EXIT CODE MESSAGE test-25324770 test,single-path PASSED 0 test-2886892866 test,subscribe PASSED 0 test-3109317976 suite,integration-tests PASSED 0 To get the logs from a specific test, use onit get logs with the test ID: > onit get logs test-2886892866 === RUN test-single-path-test --- PASS: test-single-path-test (0.04s) PASS","title":"Test Run logs"},{"location":"onos-test/docs/testing/#debugging","text":"The onit command provides a set of commands for debugging test clusters. The onit command can be used to get logs for every resource deployed in the test cluster. Simply pass the resource ID (e.g. test ID , node ID , partition ID , etc) to the onit get logs command to get the logs for a resource. To list all types of nodes (e.g. onos-topo, onos-config, etc) running in the cluster, use onit get nodes , the output will be like the following: > onit get nodes onit get nodes ID TYPE STATUS onos-topo-7cd788fb7f-2zvsp topo RUNNING onos-topo-7cd788fb7f-rc6m5 topo RUNNING onos-config-6f8fcf5954-55zn2 config RUNNING onos-config-6f8fcf5954-pglkz config RUNNING To get logs for the above node, run the following command: > onit get logs onos-config-569c7d8546-jscg8 I0625 21:55:32.027255 1 onos-config.go:114] Starting onos-config I0625 21:55:32.030184 1 manager.go:98] Configuration store loaded from /etc/onos-config/configs/configStore.json I0625 21:55:32.030358 1 manager.go:105] Change store loaded from /etc/onos-config/configs/changeStore.json I0625 21:55:32.031087 1 manager.go:112] Device store loaded from /etc/onos-config/configs/deviceStore.json I0625 21:55:32.031222 1 manager.go:119] Network store loaded from /etc/onos-config/configs/networkStore.json I0625 21:55:32.031301 1 manager.go:47] Creating Manager ... To list the Raft partitions running in the cluster, use onit get partitions : > onit get partitions ID GROUP NODES 1 raft raft-1-0 To get logs for the above partions, run the following command: > onit get logs raft-1-0 21:10:24.466 [main] INFO io.atomix.server.AtomixServerRunner - Node ID: raft-1-0 21:10:24.472 [main] INFO io.atomix.server.AtomixServerRunner - Partition Config: /etc/atomix/partition.json 21:10:24.472 [main] INFO io.atomix.server.AtomixServerRunner - Protocol Config: /etc/atomix/protocol.json 21:10:24.473 [main] INFO io.atomix.server.AtomixServerRunner - Starting server ... To list the tests that have been run, use onit get history : > onit get history ID TESTS STATUS EXIT CODE MESSAGE 3cf7311a-9776-11e9-bfc3-acde48001122 test-integration-test PASSED 0 68ad9154-977c-11e9-bcf2-acde48001122 test-integration-test FAILED 1 71a0623c-977c-11e9-8478-acde48001122 test-single-path-test PASSED 0 9e512cdc-9720-11e9-ba6e-acde48001122 * PASSED 0 da629d06-9774-11e9-bb50-acde48001122 * PASSED 0 To get logs for one of the above histories, run the following command: > onit get logs 71a0623c-977c-11e9-8478-acde48001122 === RUN test-single-path-test --- PASS: test-single-path-test (0.04s) PASS To download logs from a node, you can run onit fetch logs command. For example, to download logs from onos-config-66d54956f5-xwpsh node, run the following command: onit fetch logs onos-config-66d54956f5-xwpsh You can refer to Debug onos-config in Onit Using Delve to learn more about debugging of onos-config pod using Delve debugger.","title":"Debugging"},{"location":"onos-test/docs/testing/#api","text":"Tests are implemented using Go's testing package; func MyTest(t *testing.T) { t.Fail(\"you messed up!\") } However, rather than running tests using go test , we provide a custom registry of tests to allow human-readable names to be assigned to tests for ease of use. Once you've written a test, register the test in an init function: func init() { Registry.Register(\"my-test\", MyTest) } Once a test has been registered, you should be able to see the test via the onit command: > onit get tests my-test ... The test framework also provides the capability of adding your test to a suite defined in suites.go . To see the suites you can execute: > onit get suites SUITE TESTS alltests single-path, subscribe, transaction sometests subscribe, transaction integration-tests single-path To add your test to a suite in the init function the register method must be called with the suites parameter: func init() { Registry.RegisterTest(\"my-test\", MyTest, []*runner.TestSuite{AllTests}) } The test framework provides utility functions for creating clients and other resources within the test environment. The test environment is provided by the env package: client, err := env.NewGnmiClient(context.Background(), \"\") ... When devices are deployed in the test configuration, a list of device IDs can be retrieved from the environment: devices := env.GetDevices() onos onos-test","title":"API"},{"location":"repo-docs-1/","text":"repo-docs-1","title":"repo-docs-1"},{"location":"repo-docs-1/#repo-docs-1","text":"","title":"repo-docs-1"},{"location":"repo-docs-1/docs/","text":"","title":"Index"},{"location":"repo-docs-1/docs/test-1/","text":"Document Test 1 This is a sample document from the repo-docs-1","title":"Document Test 1"},{"location":"repo-docs-1/docs/test-1/#document-test-1","text":"This is a sample document from the repo-docs-1","title":"Document Test 1"}]}